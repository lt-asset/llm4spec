{
    "data": [
        {
            "condition": "(bag==null) == false",
            "parameters": [
                "'bag'"
            ],
            "signature": "synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)",
            "tag": "@param bag the bag to synchronize, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: "
        },
        {
            "condition": "(predicate==null) == false",
            "parameters": [
                "'queue'",
                " 'predicate'"
            ],
            "signature": "predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param predicate the predicate used to evaluate new elements, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: "
        },
        {
            "condition": "(predicate2==null) == false",
            "parameters": [
                "'predicate1'",
                " 'predicate2'"
            ],
            "signature": "andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)",
            "tag": "@param predicate2 the second predicate to check, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: "
        },
        {
            "condition": "(outputCollection==null) == false",
            "parameters": [
                "'inputCollection'",
                " 'predicate'",
                " 'outputCollection'"
            ],
            "signature": "select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)",
            "tag": "@param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: "
        },
        {
            "condition": "receiverObjectID.isLocked()",
            "parameters": [
                "'on'"
            ],
            "signature": "lockEnvironment(boolean on)",
            "tag": "@param on If true the environment is locked.",
            "tag_type": "paramTag",
            "prompt": "Signature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit,boolean cacheStdout)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String charsetName,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: filename!=null\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: lockEnvironment(boolean on)\nJavadoc: @param on If true the environment is locked.\nCondition: "
        },
        {
            "condition": "(b==null) == false",
            "parameters": [
                "'a'",
                " 'b'",
                " 'c'",
                " 'includeDuplicates'"
            ],
            "signature": "collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)",
            "tag": "@param b the second collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: "
        },
        {
            "condition": "(den==null) == false",
            "parameters": [
                "'num'",
                " 'den'"
            ],
            "signature": "BigFraction(java.math.BigInteger num,java.math.BigInteger den)",
            "tag": "@param den the denominator, must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: "
        },
        {
            "condition": "(fraction==null) == false",
            "parameters": [
                "'fraction'"
            ],
            "signature": "subtract(org.apache.commons.math3.fraction.BigFraction fraction)",
            "tag": "@param fraction BigFraction to subtract, must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: "
        },
        {
            "condition": "(b==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "union(java.lang.Iterable a,java.lang.Iterable b)",
            "tag": "@param b the second collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: "
        },
        {
            "condition": "(collection==null) == false",
            "parameters": [
                "'collection'",
                " 'elements'"
            ],
            "signature": "addAll(java.util.Collection collection,java.lang.Object[] elements)",
            "tag": "@param collection the collection to add to, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: "
        },
        {
            "condition": "maxStep>0",
            "parameters": [
                "'field'",
                " 'name'",
                " 'fsal'",
                " 'minStep'",
                " 'maxStep'",
                " 'vecAbsoluteTolerance'",
                " 'vecRelativeTolerance'"
            ],
            "signature": "org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)",
            "tag": "@param maxStep maximal step (. maxStep is positive even for backward integration).",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: "
        },
        {
            "condition": "e>0||e==0",
            "parameters": [
                "'k'",
                " 'e'"
            ],
            "signature": "pow(long k,int e)",
            "tag": "@param e Exponent (must be positive or zero).",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: "
        },
        {
            "condition": "(bytes==null) == false",
            "parameters": [
                "'bytes'",
                " 'start'",
                " 'len'"
            ],
            "signature": "nextBytes(byte[] bytes,int start,int len)",
            "tag": "@param bytes Array in which to put the generated bytes. Cannot be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: "
        },
        {
            "condition": "(bag==null) == false",
            "parameters": [
                "'bag'"
            ],
            "signature": "collectionBag(org.apache.commons.collections4.Bag<E> bag)",
            "tag": "@param bag the bag to decorate. bag must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: "
        },
        {
            "condition": "(fraction==null) == false",
            "parameters": [
                "'fraction'"
            ],
            "signature": "subtract(org.apache.commons.math3.fraction.Fraction fraction)",
            "tag": "@param fraction the fraction to subtract, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: "
        },
        {
            "condition": "(map==null) == false",
            "parameters": [
                "'map'",
                " 'factory'"
            ],
            "signature": "org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)",
            "tag": "@param map the map to decorate. map must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: "
        },
        {
            "condition": "(a==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "subtract(java.lang.Iterable a,java.lang.Iterable b)",
            "tag": "@param a the collection to subtract from, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: "
        },
        {
            "condition": "(array.length==0) == false",
            "parameters": [
                "'array'"
            ],
            "signature": "max(double[] array)",
            "tag": "@param array a nonempty array of double values",
            "tag_type": "paramTag",
            "prompt": "Signature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit,boolean cacheStdout)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String charsetName,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: filename!=null\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: lockEnvironment(boolean on)\nJavadoc: @param on If true the environment is locked.\nCondition: receiverObjectID.isLocked()\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: "
        },
        {
            "condition": "(elements==null) == false",
            "parameters": [
                "'collection'",
                " 'elements'"
            ],
            "signature": "addAll(java.util.Collection collection,java.lang.Object[] elements)",
            "tag": "@param elements the array of elements to add, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: "
        },
        {
            "condition": "(separator==null) == false",
            "parameters": [
                "'separator'"
            ],
            "signature": "on(java.lang.String separator)",
            "tag": "@param separator the literal, nonempty string to recognize as a separator",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: "
        },
        {
            "condition": "(transformer==null) == false",
            "parameters": [
                "'bag'",
                " 'transformer'"
            ],
            "signature": "transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)",
            "tag": "@param transformer the transformer for the bag, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: "
        },
        {
            "condition": "(filename==null)==false",
            "parameters": [
                "'in'",
                " 'filename'",
                " 'comment_re_string'",
                " 'include_re_string'"
            ],
            "signature": "EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)",
            "tag": "@param filename non-null file name for stream being read",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: "
        },
        {
            "condition": "(map==null) == false",
            "parameters": [
                "'map'",
                " 'factory'"
            ],
            "signature": "org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)",
            "tag": "@param map the map to decorate. map must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: "
        },
        {
            "condition": "(collection==null) == false",
            "parameters": [
                "'collection'"
            ],
            "signature": "synchronizedCollection(java.util.Collection collection)",
            "tag": "@param collection the collection to synchronize, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: "
        },
        {
            "condition": "throwable!=null",
            "parameters": [
                "'throwable'"
            ],
            "signature": "getCausalChain(java.lang.Throwable throwable)",
            "tag": "@param throwable the non-null Throwable to extract causes from",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: "
        },
        {
            "condition": "(bag==null) == false",
            "parameters": [
                "'bag'",
                " 'transformer'"
            ],
            "signature": "transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)",
            "tag": "@param bag the bag to predicate, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: "
        },
        {
            "condition": "(inputCollection==null) == false",
            "parameters": [
                "'inputCollection'",
                " 'transformer'"
            ],
            "signature": "collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)",
            "tag": "@param inputCollection the collection to get the input from, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: "
        },
        {
            "condition": "(outputCollection==null) == false",
            "parameters": [
                "'inputCollection'",
                " 'predicate'",
                " 'outputCollection'"
            ],
            "signature": "selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)",
            "tag": "@param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: "
        },
        {
            "condition": "(coll1==null) == false",
            "parameters": [
                "'coll1'",
                " 'coll2'"
            ],
            "signature": "containsAll(java.util.Collection coll1,java.util.Collection coll2)",
            "tag": "@param coll1 the first collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: "
        },
        {
            "condition": "(bag==null) == false",
            "parameters": [
                "'bag'"
            ],
            "signature": "org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)",
            "tag": "@param bag the bag to decorate. bag must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: "
        },
        {
            "condition": "minimumBits>0",
            "parameters": [
                "'minimumBits'"
            ],
            "signature": "goodFastHash(int minimumBits)",
            "tag": "@param minimumBits a positive integer (can be arbitrarily large)",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: "
        },
        {
            "condition": "(factory==null) == false",
            "parameters": [
                "'map'",
                " 'factory'"
            ],
            "signature": "org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)",
            "tag": "@param factory the factory to use. factory must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: "
        },
        {
            "condition": "upper>=lower",
            "parameters": [
                "'lower'",
                " 'upper'"
            ],
            "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)",
            "tag": "@param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: "
        },
        {
            "condition": "(predicate==null) == false",
            "parameters": [
                "'predicate'"
            ],
            "signature": "nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param predicate the predicate to wrap, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: "
        },
        {
            "condition": "(predicate2==null) == false",
            "parameters": [
                "'predicate1'",
                " 'predicate2'"
            ],
            "signature": "neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)",
            "tag": "@param predicate2 the second predicate, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: "
        },
        {
            "condition": "(b==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "isProperSubCollection(java.util.Collection a,java.util.Collection b)",
            "tag": "@param b the second (super?) collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: "
        },
        {
            "condition": "(bg==null) == false",
            "parameters": [
                "'bg'"
            ],
            "signature": "divide(java.math.BigInteger bg)",
            "tag": "@param bg the BigInteger to divide by, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: "
        },
        {
            "condition": "(predicate==null) == false",
            "parameters": [
                "'predicate'"
            ],
            "signature": "nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param predicate the predicate to wrap, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: "
        },
        {
            "condition": "(predicate2==null) == false",
            "parameters": [
                "'predicate1'",
                " 'predicate2'"
            ],
            "signature": "AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)",
            "tag": "@param predicate2 the second predicate to check, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: "
        },
        {
            "condition": "(closures==null) == false",
            "parameters": [
                "'predicates'",
                " 'closures'",
                " 'defaultClosure'"
            ],
            "signature": "switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)",
            "tag": "@param closures an array of closures to call, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param closures an array of closures to call, not null\nCondition: "
        },
        {
            "condition": "(trueClosure==null) == false",
            "parameters": [
                "'predicate'",
                " 'trueClosure'"
            ],
            "signature": "org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)",
            "tag": "@param trueClosure closure used if true. trueClosure is not null.",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: "
        },
        {
            "condition": "(b==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "isSubCollection(java.util.Collection a,java.util.Collection b)",
            "tag": "@param b the second (super?) collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: "
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'"
            ],
            "signature": "onePredicate(java.util.Collection predicates)",
            "tag": "@param predicates a collection of predicates to check, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: "
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'"
            ],
            "signature": "allPredicate(java.util.Collection predicates)",
            "tag": "@param predicates the predicates to check, cloned, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: "
        },
        {
            "condition": "(queue==null) == false",
            "parameters": [
                "'queue'",
                " 'transformer'"
            ],
            "signature": "transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)",
            "tag": "@param queue the queue to predicate, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: "
        },
        {
            "condition": "(b==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "subtract(java.lang.Iterable a,java.lang.Iterable b)",
            "tag": "@param b the collection to subtract, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: "
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'"
            ],
            "signature": "allPredicate(org.apache.commons.collections4.Predicate[] predicates)",
            "tag": "@param predicates the predicates to check, cloned, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: "
        },
        {
            "condition": "(predicate1==null) == false",
            "parameters": [
                "'predicate1'",
                " 'predicate2'"
            ],
            "signature": "AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)",
            "tag": "@param predicate1 the first predicate to check, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: "
        },
        {
            "condition": "n>=2",
            "parameters": [
                "'n'"
            ],
            "signature": "primeFactors(int n)",
            "tag": "@param n number to factorize: must be \u2265 2",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: "
        },
        {
            "condition": "(fraction==null) == false",
            "parameters": [
                "'fraction'"
            ],
            "signature": "multiply(org.apache.commons.math3.fraction.BigFraction fraction)",
            "tag": "@param fraction Fraction to multiply by, must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: "
        },
        {
            "condition": "(x==null) == false",
            "parameters": [
                "'x'",
                " 'y'",
                " 'eps'"
            ],
            "signature": "equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)",
            "tag": "@param x First value (cannot be null).",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: "
        },
        {
            "condition": "(predicate1==null) == false",
            "parameters": [
                "'predicate1'",
                " 'predicate2'"
            ],
            "signature": "andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)",
            "tag": "@param predicate1 the first predicate to check, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: "
        },
        {
            "condition": "(b==null) == false",
            "parameters": [
                "'a'",
                " 'b'",
                " 'equator'"
            ],
            "signature": "isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)",
            "tag": "@param b the second collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: "
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'"
            ],
            "signature": "allPredicate(org.apache.commons.collections4.Predicate[] predicates)",
            "tag": "@param predicates an array of predicates to check, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: "
        },
        {
            "condition": "(pair==null) == false",
            "parameters": [
                "'pair'"
            ],
            "signature": "org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)",
            "tag": "@param pair the pair to copy. pair must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: "
        },
        {
            "condition": "(coll2==null) == false",
            "parameters": [
                "'coll1'",
                " 'coll2'"
            ],
            "signature": "containsAny(java.util.Collection coll1,java.util.Collection coll2)",
            "tag": "@param coll2 the second collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: "
        },
        {
            "condition": "(b==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "collate(java.lang.Iterable a,java.lang.Iterable b)",
            "tag": "@param b the second collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: "
        },
        {
            "condition": "expectedInsertions>0",
            "parameters": [
                "'funnel'",
                " 'expectedInsertions'",
                " 'fpp'"
            ],
            "signature": "create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)",
            "tag": "@param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: "
        },
        {
            "condition": "e>0||e==0",
            "parameters": [
                "'k'",
                " 'e'"
            ],
            "signature": "pow(int k,long e)",
            "tag": "@param e Exponent (must be positive or zero).",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: "
        },
        {
            "condition": "(x==null) == false",
            "parameters": [
                "'x'",
                " 'y'"
            ],
            "signature": "equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)",
            "tag": "@param x First value (cannot be null).",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: "
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'"
            ],
            "signature": "AllPredicate(org.apache.commons.collections4.Predicate[] predicates)",
            "tag": "@param predicates the predicates to check, not cloned, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: "
        },
        {
            "condition": "(x==null) == false",
            "parameters": [
                "'x'",
                " 'y'",
                " 'maxUlps'"
            ],
            "signature": "equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)",
            "tag": "@param x First value (cannot be null).",
            "tag_type": "paramTag",
            "prompt": "Signature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: "
        },
        {
            "condition": "p!=null",
            "parameters": [
                "'p'",
                " 'timeLimit'",
                " 'cacheStdout'"
            ],
            "signature": "TimeLimitProcess(java.lang.Process p,long timeLimit,boolean cacheStdout)",
            "tag": "@param p non-null Process to limit the execution of",
            "tag_type": "paramTag",
            "prompt": "Signature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit,boolean cacheStdout)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: "
        },
        {
            "condition": "(entry==null) == false",
            "parameters": [
                "'entry'"
            ],
            "signature": "org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)",
            "tag": "@param entry the entry to copy. entry must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: "
        },
        {
            "condition": "(bag==null) == false",
            "parameters": [
                "'bag'"
            ],
            "signature": "unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)",
            "tag": "@param bag the bag whose unmodifiable view is to be returned, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: "
        },
        {
            "condition": "isLast==true",
            "parameters": [
                "'interpolator'",
                " 'isLast'"
            ],
            "signature": "handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)",
            "tag": "@param isLast isLast is true. true if the step is the last one.",
            "tag_type": "paramTag",
            "prompt": "Signature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: "
        },
        {
            "condition": "(fraction==null) == false",
            "parameters": [
                "'fraction'"
            ],
            "signature": "divide(org.apache.commons.math3.fraction.BigFraction fraction)",
            "tag": "@param fraction Fraction to divide by, must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: "
        },
        {
            "condition": "(collection==null) == false",
            "parameters": [
                "'collection'",
                " 'object'"
            ],
            "signature": "addIgnoreNull(java.util.Collection collection,java.lang.Object object)",
            "tag": "@param collection the collection to add to, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: "
        },
        {
            "condition": "(map==null) == false",
            "parameters": [
                "'map'",
                " 'factory'"
            ],
            "signature": "lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)",
            "tag": "@param map the map to decorate. map must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: "
        },
        {
            "condition": "initialStepSize>0",
            "parameters": [
                "'initialStepSize'"
            ],
            "signature": "setInitialStepSize(double initialStepSize)",
            "tag": "@param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)",
            "tag_type": "paramTag",
            "prompt": "Signature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: setInitialStepSize(double initialStepSize)\nJavadoc: @param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)\nCondition: "
        },
        {
            "condition": "(other==null) == false",
            "parameters": [
                "'other'"
            ],
            "signature": "append(java.lang.Iterable other)",
            "tag": "@param other the other iterable to combine, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: "
        },
        {
            "condition": "(array.length==0)==false",
            "parameters": [
                "'array'"
            ],
            "signature": "min(float[] array)",
            "tag": "@param array a nonempty array of float values",
            "tag_type": "paramTag",
            "prompt": "Signature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit,boolean cacheStdout)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String charsetName,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: filename!=null\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: lockEnvironment(boolean on)\nJavadoc: @param on If true the environment is locked.\nCondition: receiverObjectID.isLocked()\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: "
        },
        {
            "condition": "(y==null) == false",
            "parameters": [
                "'x'",
                " 'y'",
                " 'maxUlps'"
            ],
            "signature": "equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)",
            "tag": "@param y Second value (cannot be null).",
            "tag_type": "paramTag",
            "prompt": "Signature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: "
        },
        {
            "condition": "(factory==null) == false",
            "parameters": [
                "'map'",
                " 'factory'"
            ],
            "signature": "lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)",
            "tag": "@param factory the factory to use. factory must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: "
        },
        {
            "condition": "s>0",
            "parameters": [
                "'mu'",
                " 's'"
            ],
            "signature": "org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)",
            "tag": "@param s scale parameter (. s is positive).",
            "tag_type": "paramTag",
            "prompt": "Signature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit,boolean cacheStdout)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String charsetName,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: filename!=null\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: lockEnvironment(boolean on)\nJavadoc: @param on If true the environment is locked.\nCondition: receiverObjectID.isLocked()\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: "
        },
        {
            "condition": "m>0",
            "parameters": [
                "'n'",
                " 'm'"
            ],
            "signature": "optimalNumOfHashFunctions(long n,long m)",
            "tag": "@param m total number of bits in Bloom filter (must be positive)",
            "tag_type": "paramTag",
            "prompt": "Signature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: "
        },
        {
            "condition": "(b==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "intersection(java.lang.Iterable a,java.lang.Iterable b)",
            "tag": "@param b the second collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: "
        },
        {
            "condition": "(methodName==null) == false",
            "parameters": [
                "'methodName'"
            ],
            "signature": "invokerPredicate(java.lang.String methodName)",
            "tag": "@param methodName the method name to call on the input object, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: "
        },
        {
            "condition": "(y==null) == false",
            "parameters": [
                "'x'",
                " 'y'",
                " 'eps'"
            ],
            "signature": "equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)",
            "tag": "@param y Second value (cannot be null).",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: "
        },
        {
            "condition": "(inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false",
            "parameters": [
                "'inputCollection'",
                " 'predicate'",
                " 'outputCollection'",
                " 'rejectedCollection'"
            ],
            "signature": "select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)",
            "tag": "@param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null",
            "tag_type": "paramTag",
            "prompt": "Signature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: "
        },
        {
            "condition": "(queue==null) == false",
            "parameters": [
                "'queue'",
                " 'predicate'"
            ],
            "signature": "predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param queue the queue to predicate, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: "
        },
        {
            "condition": "(predicate1==null) == false",
            "parameters": [
                "'predicate1'",
                " 'predicate2'"
            ],
            "signature": "andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)",
            "tag": "@param predicate1 the first predicate, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: "
        },
        {
            "condition": "(predicate==null) == false",
            "parameters": [
                "'predicate'",
                " 'closure'"
            ],
            "signature": "whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)",
            "tag": "@param predicate the predicate to use as an end of loop test, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: "
        },
        {
            "condition": "minStep>0",
            "parameters": [
                "'field'",
                " 'name'",
                " 'fsal'",
                " 'minStep'",
                " 'maxStep'",
                " 'vecAbsoluteTolerance'",
                " 'vecRelativeTolerance'"
            ],
            "signature": "org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)",
            "tag": "@param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.",
            "tag_type": "paramTag",
            "prompt": "Signature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: "
        },
        {
            "condition": "nums>0",
            "parameters": [
                "'nums'"
            ],
            "signature": "missing_numbers(long[] nums)",
            "tag": "@param nums numbers to be excluded; length > 0",
            "tag_type": "paramTag",
            "prompt": "Signature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: missing_numbers(long[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: "
        },
        {
            "condition": "(array.length==0) == false",
            "parameters": [
                "'array'"
            ],
            "signature": "min(double[] array)",
            "tag": "@param array a nonempty array of double values",
            "tag_type": "paramTag",
            "prompt": "Signature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit,boolean cacheStdout)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String charsetName,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: filename!=null\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: lockEnvironment(boolean on)\nJavadoc: @param on If true the environment is locked.\nCondition: receiverObjectID.isLocked()\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: max(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: "
        },
        {
            "condition": "(others==null) == false",
            "parameters": [
                "'others'"
            ],
            "signature": "zip(java.lang.Iterable[] others)",
            "tag": "@param others the iterables to interleave, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: "
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'"
            ],
            "signature": "allPredicate(java.util.Collection predicates)",
            "tag": "@param predicates a collection of predicates to check, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: "
        },
        {
            "condition": "(closure==null) == false",
            "parameters": [
                "'predicate'",
                " 'closure'"
            ],
            "signature": "whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)",
            "tag": "@param closure the closure to call repeatedly, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: "
        },
        {
            "condition": "filename!=null",
            "parameters": [
                "'in'",
                " 'charsetName'",
                " 'filename'",
                " 'comment_re_string'",
                " 'include_re_string'"
            ],
            "signature": "EntryReader(java.io.InputStream in,java.lang.String charsetName,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)",
            "tag": "@param filename non-null file name for stream being read",
            "tag_type": "paramTag",
            "prompt": "Signature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String charsetName,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: "
        },
        {
            "condition": "(predicate1==null) == false",
            "parameters": [
                "'predicate1'",
                " 'predicate2'"
            ],
            "signature": "eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)",
            "tag": "@param predicate1 the first predicate, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: "
        },
        {
            "condition": "(other==null) == false",
            "parameters": [
                "'other'"
            ],
            "signature": "zip(java.lang.Iterable other)",
            "tag": "@param other the other iterable to interleave, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: "
        },
        {
            "condition": "(transformer==null) == false",
            "parameters": [
                "'queue'",
                " 'transformer'"
            ],
            "signature": "transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)",
            "tag": "@param transformer the transformer for the queue, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: "
        },
        {
            "condition": "(coll1==null) == false",
            "parameters": [
                "'coll1'",
                " 'coll2'"
            ],
            "signature": "containsAny(java.util.Collection coll1,java.util.Collection coll2)",
            "tag": "@param coll1 the first collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: "
        },
        {
            "condition": "(start==null) == false",
            "parameters": [
                "'f'",
                " 'start'"
            ],
            "signature": "create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)",
            "tag": "@param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.",
            "tag_type": "paramTag",
            "prompt": "Signature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: setInitialStepSize(double initialStepSize)\nJavadoc: @param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)\nCondition: initialStepSize>0\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: "
        },
        {
            "condition": "(supplier==null)==false",
            "parameters": [
                "'supplier'"
            ],
            "signature": "from(com.google.common.base.Supplier supplier)",
            "tag": "@param supplier the supplier to be used for loading values; must never return null",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: "
        },
        {
            "condition": "(bag==null) == false",
            "parameters": [
                "'bag'",
                " 'predicate'"
            ],
            "signature": "predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param bag the sorted bag to predicate, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: "
        },
        {
            "condition": "(factory==null) == false",
            "parameters": [
                "'map'",
                " 'factory'"
            ],
            "signature": "lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)",
            "tag": "@param factory the factory to use. factory must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: "
        },
        {
            "condition": "(predicate2==null) == false",
            "parameters": [
                "'predicate1'",
                " 'predicate2'"
            ],
            "signature": "andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)",
            "tag": "@param predicate2 the second predicate, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: "
        },
        {
            "condition": "(a==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "isProperSubCollection(java.util.Collection a,java.util.Collection b)",
            "tag": "@param a the first (sub?) collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: "
        },
        {
            "condition": "n>0",
            "parameters": [
                "'n'"
            ],
            "signature": "nextLong(long n)",
            "tag": "@param n the bound on the random number to be returned. Must be positive.",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: "
        },
        {
            "condition": "(predicate==null) == false",
            "parameters": [
                "'collection'",
                " 'predicate'"
            ],
            "signature": "predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param predicate the predicate for the collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: "
        },
        {
            "condition": "(a==null) == false",
            "parameters": [
                "'a'"
            ],
            "signature": "doForward(java.lang.Object a)",
            "tag": "@param a the instance to convert; will never be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: "
        },
        {
            "condition": "(lock==null) == false",
            "parameters": [
                "'bag'",
                " 'lock'"
            ],
            "signature": "SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)",
            "tag": "@param lock the lock to use, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: "
        },
        {
            "condition": "(trueClosure==null) == false",
            "parameters": [
                "'predicate'",
                " 'trueClosure'",
                " 'falseClosure'"
            ],
            "signature": "org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)",
            "tag": "@param trueClosure closure used if true. trueClosure is not null.",
            "tag_type": "paramTag",
            "prompt": "Signature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: "
        },
        {
            "condition": "s>0",
            "parameters": [
                "'rng'",
                " 'mu'",
                " 's'"
            ],
            "signature": "org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)",
            "tag": "@param s scale parameter (. s is positive).",
            "tag_type": "paramTag",
            "prompt": "Signature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit,boolean cacheStdout)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String charsetName,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: filename!=null\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: lockEnvironment(boolean on)\nJavadoc: @param on If true the environment is locked.\nCondition: receiverObjectID.isLocked()\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: "
        },
        {
            "condition": "(fraction==null) == false",
            "parameters": [
                "'fraction'"
            ],
            "signature": "multiply(org.apache.commons.math3.fraction.Fraction fraction)",
            "tag": "@param fraction the fraction to multiply by, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: "
        },
        {
            "condition": "(inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false",
            "parameters": [
                "'inputCollection'",
                " 'transformer'",
                " 'outputCollection'"
            ],
            "signature": "collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)",
            "tag": "@param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: "
        },
        {
            "condition": "n>0",
            "parameters": [
                "'n'"
            ],
            "signature": "nextPrime(int n)",
            "tag": "@param n a positive number.",
            "tag_type": "paramTag",
            "prompt": "Signature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param string any non-null string\nCondition: string!=null\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: "
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'"
            ],
            "signature": "anyPredicate(org.apache.commons.collections4.Predicate[] predicates)",
            "tag": "@param predicates an array of predicates to check, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: "
        },
        {
            "condition": "nums>0",
            "parameters": [
                "'nums'"
            ],
            "signature": "missing_numbers(int[] nums)",
            "tag": "@param nums numbers to be excluded; length > 0",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: "
        },
        {
            "condition": "(bag==null) == false",
            "parameters": [
                "'bag'"
            ],
            "signature": "unmodifiableBag(org.apache.commons.collections4.Bag bag)",
            "tag": "@param bag the bag whose unmodifiable view is to be returned, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: "
        },
        {
            "condition": "(collection==null) == false",
            "parameters": [
                "'collection'",
                " 'predicate'"
            ],
            "signature": "predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param collection the collection to predicate, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: "
        },
        {
            "condition": "(key==null) == false",
            "parameters": [
                "'key'",
                " 'bitIndex'",
                " 'lengthInBits'"
            ],
            "signature": "isBitSet(K key, int bitIndex, int lengthInBits)",
            "tag": "@param key the key to check . key is not null.",
            "tag_type": "paramTag",
            "prompt": "Signature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: "
        },
        {
            "condition": "filename!=null",
            "parameters": [
                "'reader'",
                " 'filename'"
            ],
            "signature": "plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)",
            "tag": "@param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.",
            "tag_type": "paramTag",
            "prompt": "Signature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: setInitialStepSize(double initialStepSize)\nJavadoc: @param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)\nCondition: initialStepSize>0\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: "
        },
        {
            "condition": "(fraction==null) == false",
            "parameters": [
                "'fraction'"
            ],
            "signature": "add(org.apache.commons.math3.fraction.BigFraction fraction)",
            "tag": "@param fraction the BigFraction to add, must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: "
        },
        {
            "condition": "(collection==null) == false",
            "parameters": [
                "'collection'"
            ],
            "signature": "unmodifiableCollection(java.util.Collection collection)",
            "tag": "@param collection the collection to make unmodifiable, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: "
        },
        {
            "condition": "(closure==null) == false",
            "parameters": [
                "'closure'",
                " 'predicate'"
            ],
            "signature": "doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param closure the closure to call repeatedly, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: "
        },
        {
            "condition": "n>0",
            "parameters": [
                "'n'",
                " 'p'"
            ],
            "signature": "optimalNumOfBits(long n,double p)",
            "tag": "@param n expected insertions (must be positive)",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: "
        },
        {
            "condition": "e>0||e==0",
            "parameters": [
                "'k'",
                " 'e'"
            ],
            "signature": "pow(long k,long e)",
            "tag": "@param e Exponent (must be positive or zero).",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: "
        },
        {
            "condition": "maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT",
            "parameters": [
                "'minimalIterationCount'",
                " 'maximalIterationCount'"
            ],
            "signature": "SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)",
            "tag": "@param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)",
            "tag_type": "paramTag",
            "prompt": "Signature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: setInitialStepSize(double initialStepSize)\nJavadoc: @param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)\nCondition: initialStepSize>0\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: "
        },
        {
            "condition": "(closure==null) == false",
            "parameters": [
                "'closure'"
            ],
            "signature": "forEach(org.apache.commons.collections4.Closure closure)",
            "tag": "@param closure the closure to apply to each element, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: "
        },
        {
            "condition": "maximalStep>0",
            "parameters": [
                "'minimalStep'",
                " 'maximalStep'",
                " 'absoluteTolerance'",
                " 'relativeTolerance'"
            ],
            "signature": "setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)",
            "tag": "@param maximalStep maximal step (must be positive even for backward integration)",
            "tag_type": "paramTag",
            "prompt": "Signature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: "
        },
        {
            "condition": "(b==null) == false",
            "parameters": [
                "'a'",
                " 'b'",
                " 'includeDuplicates'"
            ],
            "signature": "collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)",
            "tag": "@param b the second collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: "
        },
        {
            "condition": "(bag==null) == false",
            "parameters": [
                "'bag'"
            ],
            "signature": "synchronizedBag(org.apache.commons.collections4.Bag bag)",
            "tag": "@param bag the bag to synchronize, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: "
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'"
            ],
            "signature": "AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)",
            "tag": "@param predicates the predicates to check, not cloned, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: "
        },
        {
            "condition": "(a==null) == false",
            "parameters": [
                "'a'",
                " 'b'",
                " 'equator'"
            ],
            "signature": "isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)",
            "tag": "@param a the first collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: "
        },
        {
            "condition": "(bag==null) == false",
            "parameters": [
                "'bag'",
                " 'lock'"
            ],
            "signature": "SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)",
            "tag": "@param bag the bag to decorate, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: "
        },
        {
            "condition": "(a==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "union(java.lang.Iterable a,java.lang.Iterable b)",
            "tag": "@param a the first collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: "
        },
        {
            "condition": "(predicate==null) == false",
            "parameters": [
                "'predicate'"
            ],
            "signature": "allMatch(org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param predicate the predicate to use, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: "
        },
        {
            "condition": "expectedInsertions>0",
            "parameters": [
                "'funnel'",
                " 'expectedInsertions'"
            ],
            "signature": "create(com.google.common.hash.Funnel funnel,long expectedInsertions)",
            "tag": "@param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: "
        },
        {
            "condition": "maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT",
            "parameters": [
                "'relativeAccuracy'",
                " 'absoluteAccuracy'",
                " 'minimalIterationCount'",
                " 'maximalIterationCount'"
            ],
            "signature": "SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)",
            "tag": "@param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)",
            "tag_type": "paramTag",
            "prompt": "Signature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: setInitialStepSize(double initialStepSize)\nJavadoc: @param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)\nCondition: initialStepSize>0\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: "
        },
        {
            "condition": "(predicate==null) == false",
            "parameters": [
                "'predicate'"
            ],
            "signature": "nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param predicate the predicate to wrap, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: "
        },
        {
            "condition": "(transformer==null) == false",
            "parameters": [
                "'transformer'"
            ],
            "signature": "asPredicate(org.apache.commons.collections4.Transformer transformer)",
            "tag": "@param transformer the transformer to wrap, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: "
        },
        {
            "condition": "(bag==null) == false",
            "parameters": [
                "'bag'",
                " 'transformer'"
            ],
            "signature": "transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)",
            "tag": "@param bag the bag to predicate, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: "
        },
        {
            "condition": "p!=null",
            "parameters": [
                "'p'",
                " 'timeLimit'"
            ],
            "signature": "TimeLimitProcess(java.lang.Process p,long timeLimit)",
            "tag": "@param p non-null Process to limit the execution of",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: "
        },
        {
            "condition": "(other==null) == false",
            "parameters": [
                "'other'",
                " 'comparator'"
            ],
            "signature": "collate(java.lang.Iterable other,java.util.Comparator comparator)",
            "tag": "@param other the other iterable to collate, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: "
        },
        {
            "condition": "lower<=upper",
            "parameters": [
                "'lower'",
                " 'upper'",
                " 'tolerance'"
            ],
            "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)",
            "tag": "@param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: "
        },
        {
            "condition": "(methodName==null) == false",
            "parameters": [
                "'methodName'",
                " 'paramTypes'",
                " 'args'"
            ],
            "signature": "invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)",
            "tag": "@param methodName the method name to call on the input object, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: "
        },
        {
            "condition": "bytes!=null",
            "parameters": [
                "'bytes'"
            ],
            "signature": "nextBytes(byte[] bytes)",
            "tag": "@param bytes the non-null byte array in which to put the random bytes",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: "
        },
        {
            "condition": "(falseClosure==null) == false",
            "parameters": [
                "'predicate'",
                " 'trueClosure'",
                " 'falseClosure'"
            ],
            "signature": "org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)",
            "tag": "@param falseClosure closure used if false. falseClosure is not null.",
            "tag_type": "paramTag",
            "prompt": "Signature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: "
        },
        {
            "condition": "(enumeration==null) == false",
            "parameters": [
                "'collection'",
                " 'enumeration'"
            ],
            "signature": "addAll(java.util.Collection collection,java.util.Enumeration enumeration)",
            "tag": "@param enumeration the enumeration of elements to add, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: "
        },
        {
            "condition": "(predicate1==null) == false",
            "parameters": [
                "'predicate1'",
                " 'predicate2'"
            ],
            "signature": "orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)",
            "tag": "@param predicate1 the first predicate, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: "
        },
        {
            "condition": "fpp>0 && fpp<1.0",
            "parameters": [
                "'funnel'",
                " 'expectedInsertions'",
                " 'fpp'"
            ],
            "signature": "create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)",
            "tag": "@param fpp the desired false positive probability (must be positive and less than 1.0)",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: "
        },
        {
            "condition": "(function==null)==false",
            "parameters": [
                "'function'"
            ],
            "signature": "from(com.google.common.base.Function function)",
            "tag": "@param function the function to be used for loading values; must never return null",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: "
        },
        {
            "condition": "(bg==null) == false",
            "parameters": [
                "'bg'"
            ],
            "signature": "subtract(java.math.BigInteger bg)",
            "tag": "@param bg the BigInteger to subtract, cannot be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: "
        },
        {
            "condition": "(a==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "isEqualCollection(java.util.Collection a,java.util.Collection b)",
            "tag": "@param a the first collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: "
        },
        {
            "condition": "(fraction==null) == false",
            "parameters": [
                "'fraction'"
            ],
            "signature": "add(org.apache.commons.math3.fraction.Fraction fraction)",
            "tag": "@param fraction the fraction to add, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: "
        },
        {
            "condition": "(a==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "disjunction(java.lang.Iterable a,java.lang.Iterable b)",
            "tag": "@param a the first collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: "
        },
        {
            "condition": "(array.length==0)==false",
            "parameters": [
                "'array'"
            ],
            "signature": "max(float[] array)",
            "tag": "@param array a nonempty array of float values",
            "tag_type": "paramTag",
            "prompt": "Signature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit,boolean cacheStdout)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String charsetName,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: filename!=null\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: lockEnvironment(boolean on)\nJavadoc: @param on If true the environment is locked.\nCondition: receiverObjectID.isLocked()\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: "
        },
        {
            "condition": "key!=null",
            "parameters": [
                "'key'"
            ],
            "signature": "load(java.lang.Object key)",
            "tag": "@param key the non-null key whose value should be loaded",
            "tag_type": "paramTag",
            "prompt": "Signature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: "
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'"
            ],
            "signature": "nonePredicate(java.util.Collection predicates)",
            "tag": "@param predicates a collection of predicates to check, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: "
        },
        {
            "condition": "(map==null) == false",
            "parameters": [
                "'map'",
                " 'factory'"
            ],
            "signature": "lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)",
            "tag": "@param map the map to decorate. map must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: "
        },
        {
            "condition": "(iterable==null) == false",
            "parameters": [
                "'iterable'"
            ],
            "signature": "of(java.lang.Iterable iterable)",
            "tag": "@param iterable the iterable to wrap into a FluentIterable, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: "
        },
        {
            "condition": "string!=null",
            "parameters": [
                "'string'",
                " 'count'"
            ],
            "signature": "repeat(java.lang.String string,int count)",
            "tag": "@param string any non-null string",
            "tag_type": "paramTag",
            "prompt": "Signature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param string any non-null string\nCondition: "
        },
        {
            "condition": "(x==null) == false",
            "parameters": [
                "'x'",
                " 'y'",
                " 'eps'"
            ],
            "signature": "equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)",
            "tag": "@param x First value (cannot be null).",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: "
        },
        {
            "condition": "(queue==null) == false",
            "parameters": [
                "'queue'"
            ],
            "signature": "unmodifiableQueue(java.util.Queue queue)",
            "tag": "@param queue the queue to make unmodifiable, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: "
        },
        {
            "condition": "(y==null) == false",
            "parameters": [
                "'x'",
                " 'y'",
                " 'eps'"
            ],
            "signature": "equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)",
            "tag": "@param y Second value (cannot be null).",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: "
        },
        {
            "condition": "(bytes==null) == false",
            "parameters": [
                "'bytes'"
            ],
            "signature": "nextBytes(byte[] bytes)",
            "tag": "@param bytes Array in which to put the generated bytes. Cannot be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: "
        },
        {
            "condition": "expectedInsertions>0",
            "parameters": [
                "'funnel'",
                " 'expectedInsertions'",
                " 'fpp'"
            ],
            "signature": "create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)",
            "tag": "@param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: "
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'"
            ],
            "signature": "anyPredicate(java.util.Collection predicates)",
            "tag": "@param predicates the predicates to check, cloned, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: "
        },
        {
            "condition": "(collection==null) == false",
            "parameters": [
                "'collection'",
                " 'iterable'"
            ],
            "signature": "addAll(java.util.Collection collection,java.lang.Iterable iterable)",
            "tag": "@param collection the collection to add to, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: "
        },
        {
            "condition": "e>0||e==0",
            "parameters": [
                "'k'",
                " 'e'"
            ],
            "signature": "pow(java.math.BigInteger k,java.math.BigInteger e)",
            "tag": "@param e Exponent (must be positive or zero).",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: "
        },
        {
            "condition": "(bg==null) == false",
            "parameters": [
                "'bg'"
            ],
            "signature": "add(java.math.BigInteger bg)",
            "tag": "@param bg the BigInteger to add, must'nt be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: "
        },
        {
            "condition": "strictChecking==false",
            "parameters": [
                "'id'",
                " 'strictChecking'",
                " 'autoCreate'",
                " 'initialNodeCapacity'",
                " 'initialEdgeCapacity'"
            ],
            "signature": "MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)",
            "tag": "@param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.",
            "tag_type": "paramTag",
            "prompt": "Signature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: setInitialStepSize(double initialStepSize)\nJavadoc: @param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)\nCondition: initialStepSize>0\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: "
        },
        {
            "condition": "(b==null) == false",
            "parameters": [
                "'a'",
                " 'b'",
                " 'c'"
            ],
            "signature": "collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)",
            "tag": "@param b the second collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: "
        },
        {
            "condition": "(collection==null) == false",
            "parameters": [
                "'collection'",
                " 'transformer'"
            ],
            "signature": "transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)",
            "tag": "@param collection the collection to predicate, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: "
        },
        {
            "condition": "(a==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "collate(java.lang.Iterable a,java.lang.Iterable b)",
            "tag": "@param a the first collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: "
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'"
            ],
            "signature": "anyPredicate(java.util.Collection predicates)",
            "tag": "@param predicates a collection of predicates to check, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: "
        },
        {
            "condition": "(transformer==null) == false",
            "parameters": [
                "'bag'",
                " 'transformer'"
            ],
            "signature": "transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)",
            "tag": "@param transformer the transformer for the bag, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: "
        },
        {
            "condition": "(bag==null) == false",
            "parameters": [
                "'bag'"
            ],
            "signature": "collectionBag(org.apache.commons.collections4.Bag bag)",
            "tag": "@param bag the bag to decorate, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: "
        },
        {
            "condition": "(coll==null) == false",
            "parameters": [
                "'coll'"
            ],
            "signature": "getCardinalityMap(java.lang.Iterable coll)",
            "tag": "@param coll the collection to get the cardinality map for, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: "
        },
        {
            "condition": "(a==null) == false",
            "parameters": [
                "'a'",
                " 'b'",
                " 'p'"
            ],
            "signature": "subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)",
            "tag": "@param a the collection to subtract from, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: "
        },
        {
            "condition": "(inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false",
            "parameters": [
                "'inputIterator'",
                " 'transformer'",
                " 'outputCollection'"
            ],
            "signature": "collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)",
            "tag": "@param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: "
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'"
            ],
            "signature": "nonePredicate(org.apache.commons.collections4.Predicate[] predicates)",
            "tag": "@param predicates an array of predicates to check, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: "
        },
        {
            "condition": "(a==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "intersection(java.lang.Iterable a,java.lang.Iterable b)",
            "tag": "@param a the first collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: "
        },
        {
            "condition": "key!=null",
            "parameters": [
                "'key'",
                " 'oldValue'"
            ],
            "signature": "reload(java.lang.Object key,java.lang.Object oldValue)",
            "tag": "@param key the non-null key whose value should be loaded",
            "tag_type": "paramTag",
            "prompt": "Signature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: "
        },
        {
            "condition": "(predicate==null) == false",
            "parameters": [
                "'predicate'",
                " 'trueClosure'",
                " 'falseClosure'"
            ],
            "signature": "org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)",
            "tag": "@param predicate predicate to switch on. predicate is not null.",
            "tag_type": "paramTag",
            "prompt": "Signature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: "
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'"
            ],
            "signature": "anyPredicate(org.apache.commons.collections4.Predicate[] predicates)",
            "tag": "@param predicates the predicates to check, cloned, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: "
        },
        {
            "condition": "(b==null) == false",
            "parameters": [
                "'a'",
                " 'b'",
                " 'p'"
            ],
            "signature": "subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)",
            "tag": "@param b the collection to subtract, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: "
        },
        {
            "condition": "n>0",
            "parameters": [
                "'n'"
            ],
            "signature": "nextInt(int n)",
            "tag": "@param n the bound on the random number to be returned. Must be positive.",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: "
        },
        {
            "condition": "(array.length==0) == false",
            "parameters": [
                "'array'"
            ],
            "signature": "min(short[] array)",
            "tag": "@param array a nonempty array of short values",
            "tag_type": "paramTag",
            "prompt": "Signature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit,boolean cacheStdout)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String charsetName,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: filename!=null\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: EntryReader(java.io.InputStream in,java.lang.String filename,java.lang.String comment_re_string,java.lang.String include_re_string)\nJavadoc: @param filename non-null file name for stream being read\nCondition: (filename==null)==false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: lockEnvironment(boolean on)\nJavadoc: @param on If true the environment is locked.\nCondition: receiverObjectID.isLocked()\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: "
        },
        {
            "condition": "(collection==null) == false",
            "parameters": [
                "'collection'",
                " 'enumeration'"
            ],
            "signature": "addAll(java.util.Collection collection,java.util.Enumeration enumeration)",
            "tag": "@param collection the collection to add to, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: "
        },
        {
            "condition": "(closures==null) == false",
            "parameters": [
                "'predicates'",
                " 'closures'"
            ],
            "signature": "switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)",
            "tag": "@param closures an array of closures to call, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition: (closures==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param closures an array of closures to call, not null\nCondition:"
        },
        {
            "condition": "(a==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "isSubCollection(java.util.Collection a,java.util.Collection b)",
            "tag": "@param a the first (sub?) collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition:"
        },
        {
            "condition": "(bag==null) == false",
            "parameters": [
                "'bag'"
            ],
            "signature": "synchronizedBag(org.apache.commons.collections4.Bag bag)",
            "tag": "@param bag the bag to decorate, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition:"
        },
        {
            "condition": "(bag==null) == false",
            "parameters": [
                "'bag'",
                " 'predicate'"
            ],
            "signature": "predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param bag the bag to predicate, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition:"
        },
        {
            "condition": "length>0",
            "parameters": [
                "'length'"
            ],
            "signature": "fixedLength(int length)",
            "tag": "@param length the desired length of pieces after splitting, a positive integer",
            "tag_type": "paramTag",
            "prompt": "Signature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: missing_numbers(long[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: on(java.lang.String separator)\nJavadoc: @param separator the literal, nonempty string to recognize as a separator\nCondition: (separator==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: setInitialStepSize(double initialStepSize)\nJavadoc: @param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)\nCondition: initialStepSize>0\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition:"
        },
        {
            "condition": "minimalStep>0",
            "parameters": [
                "'minimalStep'",
                " 'maximalStep'",
                " 'absoluteTolerance'",
                " 'relativeTolerance'"
            ],
            "signature": "setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)",
            "tag": "@param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this",
            "tag_type": "paramTag",
            "prompt": "Signature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: setInitialStepSize(double initialStepSize)\nJavadoc: @param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)\nCondition: initialStepSize>0\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition:"
        },
        {
            "condition": "base>0",
            "parameters": [
                "'base'",
                " 'x'"
            ],
            "signature": "log(double base,double x)",
            "tag": "@param base Base of the logarithm, must be greater than 0.",
            "tag_type": "paramTag",
            "prompt": "Signature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition:"
        },
        {
            "condition": "(predicate==null) == false",
            "parameters": [
                "'predicate'",
                " 'trueClosure'"
            ],
            "signature": "org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)",
            "tag": "@param predicate predicate to switch on. predicate is not null.",
            "tag_type": "paramTag",
            "prompt": "Signature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition:"
        },
        {
            "condition": "e>0||e==0",
            "parameters": [
                "'k'",
                " 'e'"
            ],
            "signature": "pow(int k,int e)",
            "tag": "@param e Exponent (must be positive or zero).",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: pow(java.math.BigInteger k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition:"
        },
        {
            "condition": "expectedInsertions>0",
            "parameters": [
                "'funnel'",
                " 'expectedInsertions'"
            ],
            "signature": "create(com.google.common.hash.Funnel funnel,int expectedInsertions)",
            "tag": "@param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive",
            "tag_type": "paramTag",
            "prompt": "Signature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition:"
        },
        {
            "condition": "(bag==null) == false",
            "parameters": [
                "'bag'"
            ],
            "signature": "SynchronizedBag(org.apache.commons.collections4.Bag bag)",
            "tag": "@param bag the bag to decorate, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: forEach(org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to apply to each element, may not be null\nCondition: (closure==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: unmodifiableBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag whose unmodifiable view is to be returned, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedSortedBag(org.apache.commons.collections4.SortedBag bag)\nJavadoc: @param bag the bag to synchronize, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: synchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag)\nJavadoc: @param bag the bag to decorate, must not be null\nCondition:"
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'",
                " 'closures'",
                " 'defaultClosure'"
            ],
            "signature": "switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)",
            "tag": "@param predicates an array of predicates to check, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition:"
        },
        {
            "condition": "(inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false",
            "parameters": [
                "'inputCollection'",
                " 'predicate'",
                " 'outputCollection'",
                " 'rejectedCollection'"
            ],
            "signature": "select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)",
            "tag": "@param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null",
            "tag_type": "paramTag",
            "prompt": "Signature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition:"
        },
        {
            "condition": "(predicate2==null) == false",
            "parameters": [
                "'predicate1'",
                " 'predicate2'"
            ],
            "signature": "orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)",
            "tag": "@param predicate2 the second predicate, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition:"
        },
        {
            "condition": "countMap.isEmpty()",
            "parameters": [
                "'countMap'"
            ],
            "signature": "ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)",
            "tag": "@param countMap backing map for storing the elements in the multiset and their counts. It must be empty.",
            "tag_type": "paramTag",
            "prompt": "Signature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.bag.CollectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: collectionBag(org.apache.commons.collections4.Bag<E> bag)\nJavadoc: @param bag the bag to decorate. bag must not be null.\nCondition: (bag==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition:"
        },
        {
            "condition": "fpp>0 && fpp<1.0",
            "parameters": [
                "'funnel'",
                " 'expectedInsertions'",
                " 'fpp'"
            ],
            "signature": "create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)",
            "tag": "@param fpp the desired false positive probability (must be positive and less than 1.0)",
            "tag_type": "paramTag",
            "prompt": "Signature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition: (bases==null) == false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: plume.EntryReader$FlnReader(java.io.Reader reader, java.lang.String filename)\nJavadoc: @param filename file name corresponding to reader for use in error messages. filename Must be !=null; if there isn't a name clients should provide a dummy value.\nCondition: filename!=null\n\n###\n\nSignature: setInitialStepSize(double initialStepSize)\nJavadoc: @param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)\nCondition: initialStepSize>0\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit,boolean cacheStdout)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: TimeLimitProcess(java.lang.Process p,long timeLimit)\nJavadoc: @param p non-null Process to limit the execution of\nCondition: p!=null\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition:"
        },
        {
            "condition": "(transformer==null) == false",
            "parameters": [
                "'collection'",
                " 'transformer'"
            ],
            "signature": "transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)",
            "tag": "@param transformer the transformer for the collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition:"
        },
        {
            "condition": "(predicate2==null) == false",
            "parameters": [
                "'predicate1'",
                " 'predicate2'"
            ],
            "signature": "eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)",
            "tag": "@param predicate2 the second predicate, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition:"
        },
        {
            "condition": "(collection==null) == false",
            "parameters": [
                "'collection'"
            ],
            "signature": "permutations(java.util.Collection collection)",
            "tag": "@param collection the collection to create permutations for, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition:"
        },
        {
            "condition": "maximalStep>0",
            "parameters": [
                "'minimalStep'",
                " 'maximalStep'",
                " 'absoluteTolerance'",
                " 'relativeTolerance'"
            ],
            "signature": "setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)",
            "tag": "@param maximalStep maximal step (must be positive even for backward integration)",
            "tag_type": "paramTag",
            "prompt": "Signature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: setInitialStepSize(double initialStepSize)\nJavadoc: @param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)\nCondition: initialStepSize>0\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition:"
        },
        {
            "condition": "oldValue!=null",
            "parameters": [
                "'key'",
                " 'oldValue'"
            ],
            "signature": "reload(java.lang.Object key,java.lang.Object oldValue)",
            "tag": "@param oldValue the non-null old value corresponding to key",
            "tag_type": "paramTag",
            "prompt": "Signature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition:"
        },
        {
            "condition": "strictChecking==false",
            "parameters": [
                "'id'",
                " 'strictChecking'",
                " 'autoCreate'"
            ],
            "signature": "MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)",
            "tag": "@param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.",
            "tag_type": "paramTag",
            "prompt": "Signature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param falseClosure closure used if false. falseClosure is not null.\nCondition: (falseClosure==null) == false\n\n###\n\nSignature: lockEnvironment(boolean on)\nJavadoc: @param on If true the environment is locked.\nCondition: receiverObjectID.isLocked()\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param trueClosure closure used if true. trueClosure is not null.\nCondition: (trueClosure==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(org.apache.commons.collections4.KeyValue<? pair)\nJavadoc: @param pair the pair to copy. pair must not be null.\nCondition: (pair==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: setInitialStepSize(double initialStepSize)\nJavadoc: @param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)\nCondition: initialStepSize>0\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition:"
        },
        {
            "condition": "(inputCollection==null) == false",
            "parameters": [
                "'inputCollection'",
                " 'predicate'"
            ],
            "signature": "select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param inputCollection the collection to get the input from, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition:"
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'",
                " 'closures'"
            ],
            "signature": "switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)",
            "tag": "@param predicates an array of predicates to check, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition:"
        },
        {
            "condition": "(iterable==null) == false",
            "parameters": [
                "'collection'",
                " 'iterable'"
            ],
            "signature": "addAll(java.util.Collection collection,java.lang.Iterable iterable)",
            "tag": "@param iterable the iterable of elements to add, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition:"
        },
        {
            "condition": "(type==null) == false",
            "parameters": [
                "'type'"
            ],
            "signature": "instanceofPredicate(java.lang.Class type)",
            "tag": "@param type the type to check for, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param string any non-null string\nCondition: string!=null\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition:"
        },
        {
            "condition": "(inputCollection==null) == false",
            "parameters": [
                "'inputCollection'",
                " 'predicate'"
            ],
            "signature": "selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param inputCollection the collection to get the input from, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputCollection and transformer are not null\nCondition: (inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition:"
        },
        {
            "condition": "(predicate==null) == false",
            "parameters": [
                "'predicate'"
            ],
            "signature": "anyMatch(org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param predicate the predicate to use, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition:"
        },
        {
            "condition": "lower<=upper",
            "parameters": [
                "'lower'",
                " 'upper'"
            ],
            "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)",
            "tag": "@param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).",
            "tag_type": "paramTag",
            "prompt": "Signature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: min(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition:"
        },
        {
            "condition": "(y==null) == false",
            "parameters": [
                "'x'",
                " 'y'"
            ],
            "signature": "equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)",
            "tag": "@param y Second value (cannot be null).",
            "tag_type": "paramTag",
            "prompt": "Signature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition:"
        },
        {
            "condition": "(sequence<0) == false && (sequence>start.length()) == false",
            "parameters": [
                "'sequence'",
                " 'start'"
            ],
            "signature": "indexIn(java.lang.CharSequence sequence,int start)",
            "tag": "@param start the first index to examine; must be nonnegative and no greater than sequence.length()",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: setInitialStepSize(double initialStepSize)\nJavadoc: @param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)\nCondition: initialStepSize>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition:"
        },
        {
            "condition": "(object==null) == false",
            "parameters": [
                "'object'"
            ],
            "signature": "compareTo(org.apache.commons.math3.fraction.BigFraction object)",
            "tag": "@param object the object to compare to, must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition:"
        },
        {
            "condition": "e>0||e==0",
            "parameters": [
                "'k'",
                " 'e'"
            ],
            "signature": "pow(java.math.BigInteger k,int e)",
            "tag": "@param e Exponent (must be positive or zero).",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(java.math.BigInteger k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition:"
        },
        {
            "condition": "(predicate==null) == false",
            "parameters": [
                "'bag'",
                " 'predicate'"
            ],
            "signature": "predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param predicate the predicate for the bag, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the sorted bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition:"
        },
        {
            "condition": "(b==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "isEqualCollection(java.util.Collection a,java.util.Collection b)",
            "tag": "@param b the second collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition:"
        },
        {
            "condition": "(array.length==0) == false",
            "parameters": [
                "'array'"
            ],
            "signature": "max(short[] array)",
            "tag": "@param array a nonempty array of short values",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition:"
        },
        {
            "condition": "(count<0) == false",
            "parameters": [
                "'string'",
                " 'count'"
            ],
            "signature": "repeat(java.lang.String string,int count)",
            "tag": "@param count the number of times to repeat it; a nonnegative integer",
            "tag_type": "paramTag",
            "prompt": "Signature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: min(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param closure the closure to call repeatedly, not null\nCondition: (closure==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: missing_numbers(long[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: ConcurrentHashMultiset(java.util.concurrent.ConcurrentMap countMap)\nJavadoc: @param countMap backing map for storing the elements in the multiset and their counts. It must be empty.\nCondition: countMap.isEmpty()\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition:"
        },
        {
            "condition": "(coll2==null) == false",
            "parameters": [
                "'coll1'",
                " 'coll2'"
            ],
            "signature": "containsAll(java.util.Collection coll1,java.util.Collection coll2)",
            "tag": "@param coll2 the second collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition:"
        },
        {
            "condition": "(fraction==null) == false",
            "parameters": [
                "'fraction'"
            ],
            "signature": "divide(org.apache.commons.math3.fraction.Fraction fraction)",
            "tag": "@param fraction the fraction to divide by, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition:"
        },
        {
            "condition": "(bases==null) == false",
            "parameters": [
                "'dimension'",
                " 'bases'",
                " 'weights'"
            ],
            "signature": "org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)",
            "tag": "@param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.",
            "tag_type": "paramTag",
            "prompt": "Signature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: min(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param string any non-null string\nCondition: string!=null\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes the non-null byte array in which to put the random bytes\nCondition: bytes!=null\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes,int start,int len)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: nextBytes(byte[] bytes)\nJavadoc: @param bytes Array in which to put the generated bytes. Cannot be null.\nCondition: (bytes==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: org.apache.commons.math3.random.HaltonSequenceGenerator(int dimension, int[] bases, int[] weights)\nJavadoc: @param bases the base number for each dimension entries should be (pairwise) prime . bases is not null.\nCondition:"
        },
        {
            "condition": "upper>=lower",
            "parameters": [
                "'lower'",
                " 'upper'",
                " 'tolerance'"
            ],
            "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)",
            "tag": "@param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).",
            "tag_type": "paramTag",
            "prompt": "Signature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: pow(java.math.BigInteger k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param fpp the desired false positive probability (must be positive and less than 1.0)\nCondition: fpp>0 && fpp<1.0\n\n###\n\nSignature: max(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: min(short[] array)\nJavadoc: @param array a nonempty array of short values\nCondition: (array.length==0) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: max(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: min(float[] array)\nJavadoc: @param array a nonempty array of float values\nCondition: (array.length==0)==false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: min(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: max(double[] array)\nJavadoc: @param array a nonempty array of double values\nCondition: (array.length==0) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition:"
        },
        {
            "condition": "(predicate==null) == false",
            "parameters": [
                "'bag'",
                " 'predicate'"
            ],
            "signature": "predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param predicate the predicate for the bag, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param bag the bag to predicate, must not be null\nCondition: (bag==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition:"
        },
        {
            "condition": "(iterator==null) == false",
            "parameters": [
                "'collection'",
                " 'iterator'"
            ],
            "signature": "addAll(java.util.Collection collection,java.util.Iterator iterator)",
            "tag": "@param iterator the iterator of elements to add, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param outputCollection the collection to output selected elements into, may not be null if the inputCollection and predicate are not null\nCondition: (inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: collect(java.util.Iterator inputIterator,org.apache.commons.collections4.Transformer transformer,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if inputIterator and transformer are not null\nCondition: (inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition:"
        },
        {
            "condition": "(num==null) == false",
            "parameters": [
                "'num'",
                " 'den'"
            ],
            "signature": "BigFraction(java.math.BigInteger num,java.math.BigInteger den)",
            "tag": "@param num the numerator, must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: repeat(java.lang.String string,int count)\nJavadoc: @param string any non-null string\nCondition: string!=null\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction BigFraction to subtract, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param den the denominator, must not be null.\nCondition: (den==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction the BigFraction to add, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: missing_numbers(long[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to divide by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: divide(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to divide by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: subtract(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to subtract, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: add(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to add, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition:"
        },
        {
            "condition": "(b==null) == false",
            "parameters": [
                "'a'",
                " 'b'"
            ],
            "signature": "disjunction(java.lang.Iterable a,java.lang.Iterable b)",
            "tag": "@param b the second collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition:"
        },
        {
            "condition": "q>0",
            "parameters": [
                "'function'",
                " 'initial'",
                " 'lowerBound'",
                " 'upperBound'",
                " 'q'",
                " 'r'",
                " 'maximumIterations'"
            ],
            "signature": "bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)",
            "tag": "@param q additive offset used to compute bounds sequence (must be strictly positive)",
            "tag_type": "paramTag",
            "prompt": "Signature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: unmodifiableQueue(java.util.Queue queue)\nJavadoc: @param queue the queue to make unmodifiable, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: missing_numbers(long[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: fixedLength(int length)\nJavadoc: @param length the desired length of pieces after splitting, a positive integer\nCondition: length>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param queue the queue to predicate, must not be null\nCondition: (queue==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: setInitialStepSize(double initialStepSize)\nJavadoc: @param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)\nCondition: initialStepSize>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition:"
        },
        {
            "condition": "(a==null) == false",
            "parameters": [
                "'a'",
                " 'b'",
                " 'c'",
                " 'includeDuplicates'"
            ],
            "signature": "collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)",
            "tag": "@param a the first collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition:"
        },
        {
            "condition": "n>0",
            "parameters": [
                "'n'",
                " 'm'"
            ],
            "signature": "optimalNumOfHashFunctions(long n,long m)",
            "tag": "@param n expected insertions (must be positive)",
            "tag_type": "paramTag",
            "prompt": "Signature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: missing_numbers(long[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: missing_numbers(int[] nums)\nJavadoc: @param nums numbers to be excluded; length > 0\nCondition: nums>0\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param elements the array of elements to add, must not be null\nCondition: (elements==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: repeat(java.lang.String string,int count)\nJavadoc: @param count the number of times to repeat it; a nonnegative integer\nCondition: (count<0) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,int expectedInsertions)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: create(com.google.common.hash.Funnel funnel,long expectedInsertions,double fpp)\nJavadoc: @param expectedInsertions the number of expected insertions to the constructed BloomFilter<T>; must be positive\nCondition: expectedInsertions>0\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition:"
        },
        {
            "condition": "(predicates==null) == false",
            "parameters": [
                "'predicates'"
            ],
            "signature": "onePredicate(org.apache.commons.collections4.Predicate[] predicates)",
            "tag": "@param predicates an array of predicates to check, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition:"
        },
        {
            "condition": "(predicate==null) == false",
            "parameters": [
                "'closure'",
                " 'predicate'"
            ],
            "signature": "doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)",
            "tag": "@param predicate the predicate to use as an end of loop test, not null",
            "tag_type": "paramTag",
            "prompt": "Signature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition:"
        },
        {
            "condition": "(b==null) == false",
            "parameters": [
                "'b'"
            ],
            "signature": "doBackward(java.lang.Object b)",
            "tag": "@param b the instance to convert; will never be null",
            "tag_type": "paramTag",
            "prompt": "Signature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param oldValue the non-null old value corresponding to key\nCondition: oldValue!=null\n\n###\n\nSignature: transformingBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: transformingSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the bag, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: subtract(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to subtract, cannot be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: divide(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to divide by, must not be null\nCondition: (bg==null) == false\n\n###\n\nSignature: add(java.math.BigInteger bg)\nJavadoc: @param bg the BigInteger to add, must'nt be null.\nCondition: (bg==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition:"
        },
        {
            "condition": "(factory==null) == false",
            "parameters": [
                "'map'",
                " 'factory'"
            ],
            "signature": "org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)",
            "tag": "@param factory the factory to use. factory must not be null.",
            "tag_type": "paramTag",
            "prompt": "Signature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: asPredicate(org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer to wrap, may not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: getCausalChain(java.lang.Throwable throwable)\nJavadoc: @param throwable the non-null Throwable to extract causes from\nCondition: throwable!=null\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: transformingQueue(java.util.Queue queue,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the queue, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate,int initialNodeCapacity,int initialEdgeCapacity)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: MultiGraph(java.lang.String id,boolean strictChecking,boolean autoCreate)\nJavadoc: @param autoCreate If true (and strict checking is false), nodes are automatically created when referenced when creating a edge, even if not yet inserted in the graph.\nCondition: strictChecking==false\n\n###\n\nSignature: from(com.google.common.base.Function function)\nJavadoc: @param function the function to be used for loading values; must never return null\nCondition: (function==null)==false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param map the map to decorate. map must not be null.\nCondition: (map==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.keyvalue.DefaultMapEntry(java.util.Map.java.util.Map$Entry<? entry)\nJavadoc: @param entry the entry to copy. entry must not be null.\nCondition: (entry==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param transformer the transformer for the collection, must not be null\nCondition: (transformer==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: instanceofPredicate(java.lang.Class type)\nJavadoc: @param type the type to check for, may not be null\nCondition: (type==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: load(java.lang.Object key)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: reload(java.lang.Object key,java.lang.Object oldValue)\nJavadoc: @param key the non-null key whose value should be loaded\nCondition: key!=null\n\n###\n\nSignature: isBitSet(K key, int bitIndex, int lengthInBits)\nJavadoc: @param key the key to check . key is not null.\nCondition: (key==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: SynchronizedBag(org.apache.commons.collections4.Bag bag,java.lang.Object lock)\nJavadoc: @param lock the lock to use, must not be null\nCondition: (lock==null) == false\n\n###\n\nSignature: from(com.google.common.base.Supplier supplier)\nJavadoc: @param supplier the supplier to be used for loading values; must never return null\nCondition: (supplier==null)==false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: lazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Transformer<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition: (factory==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.map.LazyMap(java.util.Map<K, map, org.apache.commons.collections4.Factory<? factory)\nJavadoc: @param factory the factory to use. factory must not be null.\nCondition:"
        },
        {
            "condition": "(a==null) == false",
            "parameters": [
                "'a'",
                " 'b'",
                " 'c'"
            ],
            "signature": "collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)",
            "tag": "@param a the first collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition:"
        },
        {
            "condition": "(collection==null) == false",
            "parameters": [
                "'collection'",
                " 'iterator'"
            ],
            "signature": "addAll(java.util.Collection collection,java.util.Iterator iterator)",
            "tag": "@param collection the collection to add to, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection)\nJavadoc: @param outputCollection the collection to output into, may not be null if the inputCollection and predicate or not null\nCondition: (outputCollection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: collect(java.lang.Iterable inputCollection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: selectRejected(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param inputCollection the collection to get the input from, may not be null\nCondition: (inputCollection==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition:"
        },
        {
            "condition": "minimalStep>0",
            "parameters": [
                "'minimalStep'",
                " 'maximalStep'",
                " 'absoluteTolerance'",
                " 'relativeTolerance'"
            ],
            "signature": "setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)",
            "tag": "@param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this",
            "tag_type": "paramTag",
            "prompt": "Signature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName,java.lang.Class[] paramTypes,java.lang.Object[] args)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: invokerPredicate(java.lang.String methodName)\nJavadoc: @param methodName the method name to call on the input object, may not be null\nCondition: (methodName==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: SimpsonIntegrator(int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: SimpsonIntegrator(double relativeAccuracy,double absoluteAccuracy,int minimalIterationCount,int maximalIterationCount)\nJavadoc: @param maximalIterationCount maximum number of iterations (must be less than or equal to SIMPSON_MAX_ITERATIONS_COUNT)\nCondition: maximalIterationCount<=receiverObjectID.SIMPSON_MAX_ITERATIONS_COUNT\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: create(org.apache.commons.math3.analysis.ParametricUnivariateFunction f,double[] start)\nJavadoc: @param start Initial guess for the parameters. Cannot be null. Its length must be consistent with the number of parameters of the function to fit.\nCondition: (start==null) == false\n\n###\n\nSignature: bracket(org.apache.commons.math3.analysis.UnivariateFunction function,double initial,double lowerBound,double upperBound,double q,double r,int maximumIterations)\nJavadoc: @param q additive offset used to compute bounds sequence (must be strictly positive)\nCondition: q>0\n\n###\n\nSignature: goodFastHash(int minimumBits)\nJavadoc: @param minimumBits a positive integer (can be arbitrarily large)\nCondition: minimumBits>0\n\n###\n\nSignature: indexIn(java.lang.CharSequence sequence,int start)\nJavadoc: @param start the first index to examine; must be nonnegative and no greater than sequence.length()\nCondition: (sequence<0) == false && (sequence>start.length()) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: handleStep(org.apache.commons.math3.ode.sampling.StepInterpolator interpolator, boolean isLast)\nJavadoc: @param isLast isLast is true. true if the step is the last one.\nCondition: isLast==true\n\n###\n\nSignature: setInitialStepSize(double initialStepSize)\nJavadoc: @param initialStepSize initial step size to use (must be positive even for backward integration ; providing a negative value or a value outside of the min/max step interval will lead the integrator to ignore the value and compute the initial step size by itself)\nCondition: initialStepSize>0\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param maxStep maximal step (. maxStep is positive even for backward integration).\nCondition: maxStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param maximalStep maximal step (must be positive even for backward integration)\nCondition: maximalStep>0\n\n###\n\nSignature: org.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator(org.apache.commons.math3.Field<T> field, java.lang.String name, int fsal, double minStep, double maxStep, double[] vecAbsoluteTolerance, double[] vecRelativeTolerance)\nJavadoc: @param minStep minimal step (. minStep is positive even for backward integration) the last step smaller than this.\nCondition: minStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double absoluteTolerance,double relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition: minimalStep>0\n\n###\n\nSignature: setStepSizeControl(double minimalStep,double maximalStep,double[] absoluteTolerance,double[] relativeTolerance)\nJavadoc: @param minimalStep minimal step (must be positive even for backward integration), the last step can be smaller than this\nCondition:"
        },
        {
            "condition": "x>0",
            "parameters": [
                "'base'",
                " 'x'"
            ],
            "signature": "log(double base,double x)",
            "tag": "@param x Argument, must be greater than 0.",
            "tag_type": "paramTag",
            "prompt": "Signature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.Fraction fraction)\nJavadoc: @param fraction the fraction to multiply by, must not be null\nCondition: (fraction==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: pow(java.math.BigInteger k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition:"
        },
        {
            "condition": "(a==null) == false",
            "parameters": [
                "'a'",
                " 'b'",
                " 'includeDuplicates'"
            ],
            "signature": "collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)",
            "tag": "@param a the first collection, must not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: select(java.lang.Iterable inputCollection,org.apache.commons.collections4.Predicate predicate,java.util.Collection outputCollection,java.util.Collection rejectedCollection)\nJavadoc: @param rejectedCollection the collection to output rejected elements into, may not be null if the inputCollection or predicate are not null\nCondition: (inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: doForward(java.lang.Object a)\nJavadoc: @param a the instance to convert; will never be null\nCondition: (a==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: permutations(java.util.Collection collection)\nJavadoc: @param collection the collection to create permutations for, may not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: unmodifiableCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to make unmodifiable, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition:"
        },
        {
            "condition": "(other==null) == false",
            "parameters": [
                "'other'"
            ],
            "signature": "collate(java.lang.Iterable other)",
            "tag": "@param other the other iterable to collate, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: addIgnoreNull(java.util.Collection collection,java.lang.Object object)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the first collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param a the first (sub?) collection, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: synchronizedCollection(java.util.Collection collection)\nJavadoc: @param collection the collection to synchronize, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param a the collection to subtract from, must not be null\nCondition: (a==null) == false\n\n###\n\nSignature: intersection(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b,org.apache.commons.collections4.Equator equator)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: disjunction(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,java.util.Comparator c)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: union(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable a,java.lang.Iterable b,boolean includeDuplicates)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isEqualCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isProperSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: isSubCollection(java.util.Collection a,java.util.Collection b)\nJavadoc: @param b the second (super?) collection, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Iterator iterator)\nJavadoc: @param iterator the iterator of elements to add, must not be null\nCondition: (iterator==null) == false\n\n###\n\nSignature: of(java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable to wrap into a FluentIterable, may not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: getCardinalityMap(java.lang.Iterable coll)\nJavadoc: @param coll the collection to get the cardinality map for, must not be null\nCondition: (coll==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll1 the first collection, must not be null\nCondition: (coll1==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param iterable the iterable of elements to add, must not be null\nCondition: (iterable==null) == false\n\n###\n\nSignature: containsAll(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: containsAny(java.util.Collection coll1,java.util.Collection coll2)\nJavadoc: @param coll2 the second collection, must not be null\nCondition: (coll2==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable[] others)\nJavadoc: @param others the iterables to interleave, may not be null\nCondition: (others==null) == false\n\n###\n\nSignature: append(java.lang.Iterable other)\nJavadoc: @param other the other iterable to combine, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: zip(java.lang.Iterable other)\nJavadoc: @param other the other iterable to interleave, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other,java.util.Comparator comparator)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition: (other==null) == false\n\n###\n\nSignature: collate(java.lang.Iterable other)\nJavadoc: @param other the other iterable to collate, may not be null\nCondition:"
        },
        {
            "condition": "(predicate1==null) == false",
            "parameters": [
                "'predicate1'",
                " 'predicate2'"
            ],
            "signature": "neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)",
            "tag": "@param predicate1 the first predicate, may not be null",
            "tag_type": "paramTag",
            "prompt": "Signature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures,org.apache.commons.collections4.Closure defaultClosure)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: switchClosure(org.apache.commons.collections4.Predicate[] predicates,org.apache.commons.collections4.Closure[] closures)\nJavadoc: @param predicates an array of predicates to check, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates an array of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AnyPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: AllPredicate(org.apache.commons.collections4.Predicate[] predicates)\nJavadoc: @param predicates the predicates to check, not cloned, not null\nCondition: (predicates==null) == false\n\n###\n\nSignature: onePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: anyPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: allPredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: nonePredicate(java.util.Collection predicates)\nJavadoc: @param predicates a collection of predicates to check, may not be null\nCondition: (predicates==null) == false\n\n###\n\nSignature: doWhileClosure(org.apache.commons.collections4.Closure closure,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: whileClosure(org.apache.commons.collections4.Predicate predicate,org.apache.commons.collections4.Closure closure)\nJavadoc: @param predicate the predicate to use as an end of loop test, not null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedSortedBag(org.apache.commons.collections4.SortedBag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedBag(org.apache.commons.collections4.Bag bag,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the bag, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: predicatedQueue(java.util.Queue queue,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate used to evaluate new elements, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: org.apache.commons.collections4.functors.IfClosure(org.apache.commons.collections4.Predicate<? predicate, org.apache.commons.collections4.Closure<? trueClosure, org.apache.commons.collections4.Closure<? falseClosure)\nJavadoc: @param predicate predicate to switch on. predicate is not null.\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsExceptionPredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsFalsePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: nullIsTruePredicate(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to wrap, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate to check, not null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate for the collection, must not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: allMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: anyMatch(org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param predicate the predicate to use, may not be null\nCondition: (predicate==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate2 the second predicate, may not be null\nCondition: (predicate2==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: AndPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate to check, not null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: eitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: orPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: andPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition: (predicate1==null) == false\n\n###\n\nSignature: neitherPredicate(org.apache.commons.collections4.Predicate predicate1,org.apache.commons.collections4.Predicate predicate2)\nJavadoc: @param predicate1 the first predicate, may not be null\nCondition:"
        },
        {
            "condition": "e>0||e==0",
            "parameters": [
                "'k'",
                " 'e'"
            ],
            "signature": "pow(java.math.BigInteger k,long e)",
            "tag": "@param e Exponent (must be positive or zero).",
            "tag_type": "paramTag",
            "prompt": "Signature: addAll(java.util.Collection collection,java.lang.Iterable iterable)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.lang.Object[] elements)\nJavadoc: @param collection the collection to add to, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param upper upper bound of the interval . upper is greater or equal to lower ( Double.POSITIVE_INFINITY).\nCondition: upper>=lower\n\n###\n\nSignature: multiply(org.apache.commons.math3.fraction.BigFraction fraction)\nJavadoc: @param fraction Fraction to multiply by, must not be null.\nCondition: (fraction==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param y Second value (cannot be null).\nCondition: (y==null) == false\n\n###\n\nSignature: transformingCollection(java.util.Collection collection,org.apache.commons.collections4.Transformer transformer)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: predicatedCollection(java.util.Collection collection,org.apache.commons.collections4.Predicate predicate)\nJavadoc: @param collection the collection to predicate, must not be null\nCondition: (collection==null) == false\n\n###\n\nSignature: primeFactors(int n)\nJavadoc: @param n number to factorize: must be \u2265 2\nCondition: n>=2\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(org.apache.commons.math3.random.RandomGenerator rng, double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: org.apache.commons.math3.distribution.LogisticDistribution(double mu, double s)\nJavadoc: @param s scale parameter (. s is positive).\nCondition: s>0\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet(double lower, double upper, double tolerance)\nJavadoc: @param lower lower bound of the interval . lower is lesser or equal to upper ( Double.NEGATIVE_INFINITY).\nCondition: lower<=upper\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param m total number of bits in Bloom filter (must be positive)\nCondition: m>0\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: subtract(java.lang.Iterable a,java.lang.Iterable b,org.apache.commons.collections4.Predicate p)\nJavadoc: @param b the collection to subtract, must not be null\nCondition: (b==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,int maxUlps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equalsWithRelativeTolerance(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y,double eps)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: equals(org.apache.commons.math3.complex.Complex x,org.apache.commons.math3.complex.Complex y)\nJavadoc: @param x First value (cannot be null).\nCondition: (x==null) == false\n\n###\n\nSignature: addAll(java.util.Collection collection,java.util.Enumeration enumeration)\nJavadoc: @param enumeration the enumeration of elements to add, must not be null\nCondition: (enumeration==null) == false\n\n###\n\nSignature: compareTo(org.apache.commons.math3.fraction.BigFraction object)\nJavadoc: @param object the object to compare to, must not be null.\nCondition: (object==null) == false\n\n###\n\nSignature: doBackward(java.lang.Object b)\nJavadoc: @param b the instance to convert; will never be null\nCondition: (b==null) == false\n\n###\n\nSignature: BigFraction(java.math.BigInteger num,java.math.BigInteger den)\nJavadoc: @param num the numerator, must not be null.\nCondition: (num==null) == false\n\n###\n\nSignature: optimalNumOfBits(long n,double p)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: optimalNumOfHashFunctions(long n,long m)\nJavadoc: @param n expected insertions (must be positive)\nCondition: n>0\n\n###\n\nSignature: nextInt(int n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: nextLong(long n)\nJavadoc: @param n the bound on the random number to be returned. Must be positive.\nCondition: n>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param x Argument, must be greater than 0.\nCondition: x>0\n\n###\n\nSignature: log(double base,double x)\nJavadoc: @param base Base of the logarithm, must be greater than 0.\nCondition: base>0\n\n###\n\nSignature: nextPrime(int n)\nJavadoc: @param n a positive number.\nCondition: n>0\n\n###\n\nSignature: pow(java.math.BigInteger k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(int k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(java.math.BigInteger k,java.math.BigInteger e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(int k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(long k,int e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition: e>0||e==0\n\n###\n\nSignature: pow(java.math.BigInteger k,long e)\nJavadoc: @param e Exponent (must be positive or zero).\nCondition:"
        }
    ]
}