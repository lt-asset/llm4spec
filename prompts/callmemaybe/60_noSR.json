{
    "data": [
        {
            "input": "Signature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the mappings from this map. The map will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Atomically removes all of the elements from this queue. The queue will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:",
            "condition": "receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)",
            "signature": "org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)",
            "comment": "Constructs a new FilterListIterator that will not function until setListIterator is invoked.",
            "returnType": "",
            "prompt": "Signature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:"
        },
        {
            "input": "Signature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:",
            "condition": "receiverObjectID.setDaemon(on)->receiverObjectID.start()",
            "signature": "setDaemon(boolean on)",
            "comment": "Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.",
            "returnType": "void",
            "prompt": "Signature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the elements from this priority queue. The queue will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:",
            "condition": "receiverObjectID.decRef()<-receiverObjectID.incRef()",
            "signature": "tryIncRef()",
            "comment": "Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.",
            "returnType": "boolean",
            "prompt": "Signature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Atomically removes all of the elements from this deque. The deque will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:",
            "condition": "receiverObjectID.remove()<-receiverObjectID.next()",
            "signature": "remove()",
            "comment": "Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.",
            "returnType": "void",
            "prompt": "Signature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:"
        },
        {
            "input": "Signature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:",
            "condition": "receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)",
            "signature": "org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)",
            "comment": "Constructs a new FilterIterator that will not function until setPredicate is invoked.",
            "returnType": "",
            "prompt": "Signature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:"
        },
        {
            "input": "Signature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:",
            "condition": "receiverObjectID.end()->!receiverObjectID",
            "signature": "end()",
            "comment": "Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.",
            "returnType": "void",
            "prompt": "Signature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:"
        },
        {
            "input": "Signature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:",
            "condition": "receiverObjectID.newSetFromMap(map)->!map",
            "signature": "newSetFromMap(java.util.Map<E, java.lang.Boolean> map)",
            "comment": "Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.",
            "returnType": "java.util.Set<E>",
            "prompt": "Signature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:"
        },
        {
            "input": "Signature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:",
            "condition": "receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)",
            "signature": "org.apache.commons.collections4.iterators.FilterIterator()",
            "comment": "Constructs a new FilterIterator that will not function until setIterator is invoked.",
            "returnType": "",
            "prompt": "Signature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the elements from this set. The set will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the mappings from this map. The map will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:",
            "condition": "receiverObjectID.decRef()<-receiverObjectID.incRef()",
            "signature": "incRef()",
            "comment": "Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.",
            "returnType": "void",
            "prompt": "Signature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:"
        },
        {
            "input": "Signature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:",
            "condition": "receiverObjectID.close()->!receiverObjectID",
            "signature": "close()",
            "comment": "Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").",
            "returnType": "void",
            "prompt": "Signature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all elements from the receiver. The receiver will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:",
            "condition": "!(receiverObjectID.add()->receiverObjectID)",
            "signature": "add(char[] text)",
            "comment": "If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.",
            "returnType": "boolean",
            "prompt": "Signature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the mappings from this map. The map will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:",
            "condition": "!(receiverObjectID.newSetFromMap(map)->map)",
            "signature": "newSetFromMap(java.util.Map<E, java.lang.Boolean> map)",
            "comment": "Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());",
            "returnType": "java.util.Set<E>",
            "prompt": "Signature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:",
            "condition": "receiverObjectID.sort()->receiverObjectID.binarySearch(key)",
            "signature": "binarySearch(char key)",
            "comment": "Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.",
            "returnType": "int",
            "prompt": "Signature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:"
        },
        {
            "input": "Signature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:",
            "condition": "receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)",
            "signature": "remove(java.lang.Object key)",
            "comment": "Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.",
            "returnType": "V",
            "prompt": "Signature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:"
        },
        {
            "input": "Signature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:",
            "condition": "receiverObjectID.setQueryCache(queryCache)->receiverObjectID",
            "signature": "setQueryCache(org.apache.lucene.search.QueryCache queryCache)",
            "comment": "Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.",
            "returnType": "void",
            "prompt": "Signature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:"
        },
        {
            "input": "Signature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:",
            "condition": "org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()",
            "signature": "prepareCommit()",
            "comment": "first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.",
            "returnType": "long",
            "prompt": "Signature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:",
            "condition": "receiverObjectID.sort()->receiverObjectID.binarySearch(key)",
            "signature": "binarySearch(byte key)",
            "comment": "Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.",
            "returnType": "int",
            "prompt": "Signature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:"
        },
        {
            "input": "Signature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:",
            "condition": "receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)",
            "signature": "setEncoding(java.lang.String encoding)",
            "comment": "Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.",
            "returnType": "void",
            "prompt": "Signature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:",
            "condition": "receiverObjectID.sort()->receiverObjectID.binarySearch(key)",
            "signature": "binarySearch(double key)",
            "comment": "Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.",
            "returnType": "int",
            "prompt": "Signature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:"
        },
        {
            "input": "Signature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:",
            "condition": "receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)",
            "signature": "org.apache.commons.collections4.iterators.FilterListIterator()",
            "comment": "Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.",
            "returnType": "",
            "prompt": "Signature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:"
        },
        {
            "input": "Signature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:",
            "condition": "org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)",
            "signature": "begin(java.io.InputStream stream)",
            "comment": "Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.",
            "returnType": "void",
            "prompt": "Signature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the elements from this deque. The deque will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the elements from this list (optional operation). The list will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.",
            "returnType": "void",
            "prompt": "Signature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:"
        },
        {
            "input": "Signature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:",
            "condition": "receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)",
            "signature": "org.apache.commons.collections4.iterators.IteratorEnumeration()",
            "comment": "Constructs a new IteratorEnumeration that will not function until setIterator is invoked.",
            "returnType": "",
            "prompt": "Signature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:",
            "condition": "receiverObjectID.sort()->receiverObjectID.binarySearch(key)",
            "signature": "binarySearch(short key)",
            "comment": "Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.",
            "returnType": "int",
            "prompt": "Signature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:"
        },
        {
            "input": "Signature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:",
            "condition": "receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)",
            "signature": "setBottom(int slot)",
            "comment": "Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).",
            "returnType": "void",
            "prompt": "Signature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:",
            "condition": "Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)",
            "signature": "binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)",
            "comment": "Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.",
            "returnType": "int",
            "prompt": "Signature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).",
            "returnType": "void",
            "prompt": "Signature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:"
        },
        {
            "input": "Signature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:",
            "condition": "receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID",
            "signature": "setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)",
            "comment": "Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.",
            "returnType": "void",
            "prompt": "Signature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.",
            "returnType": "void",
            "prompt": "Signature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:"
        },
        {
            "input": "Signature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:",
            "condition": "receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)",
            "signature": "org.apache.commons.collections4.iterators.EnumerationIterator()",
            "comment": "Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.",
            "returnType": "",
            "prompt": "Signature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:"
        },
        {
            "input": "Signature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:",
            "condition": "receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()",
            "signature": "deactivateEvents()",
            "comment": "De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.",
            "returnType": "void",
            "prompt": "Signature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:",
            "condition": "receiverObjectID.sort()->receiverObjectID.binarySearch(key)",
            "signature": "binarySearch(long key)",
            "comment": "Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.",
            "returnType": "int",
            "prompt": "Signature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:"
        },
        {
            "input": "Signature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:",
            "condition": "receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)",
            "signature": "setEncoding(java.lang.String encoding)",
            "comment": "Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.",
            "returnType": "void",
            "prompt": "Signature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:"
        },
        {
            "input": "Signature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:",
            "condition": "receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)",
            "signature": "org.apache.commons.collections4.iterators.TransformIterator()",
            "comment": "Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.",
            "returnType": "",
            "prompt": "Signature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:"
        },
        {
            "input": "Signature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:",
            "condition": "receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()",
            "signature": "defineDataFormat()",
            "comment": "Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.",
            "returnType": "weka.core.Instances",
            "prompt": "Signature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:"
        },
        {
            "input": "Signature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:",
            "condition": "Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)",
            "signature": "removeAll(java.util.Collection<?> c)",
            "comment": "Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.",
            "returnType": "boolean",
            "prompt": "Signature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the elements from this set (optional operation). The set will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:",
            "condition": "receiverObjectID.remove(o)->!receiverObjectID.contains(o)",
            "signature": "remove(java.lang.Object o)",
            "comment": "Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)",
            "returnType": "boolean",
            "prompt": "Signature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Atomically removes all of the elements from this queue. The queue will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:",
            "condition": "org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)",
            "signature": "begin(java.io.Reader reader)",
            "comment": "Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.",
            "returnType": "void",
            "prompt": "Signature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the elements from this set. The set will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:",
            "condition": "receiverObjectID.sort()->receiverObjectID.binarySearch(key)",
            "signature": "binarySearch(int key)",
            "comment": "Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.",
            "returnType": "int",
            "prompt": "Signature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the elements from this set. The set will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:",
            "condition": "java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)",
            "signature": "binarySearch(double[] a, double key)",
            "comment": "Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.",
            "returnType": "int",
            "prompt": "Signature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:",
            "condition": "receiverObjectID.sort()->receiverObjectID.binarySearch(key)",
            "signature": "binarySearch(boolean key)",
            "comment": "Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.",
            "returnType": "int",
            "prompt": "Signature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:",
            "condition": "java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)",
            "signature": "binarySearch(short[] a, short key)",
            "comment": "Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
            "returnType": "int",
            "prompt": "Signature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:",
            "condition": "java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)",
            "signature": "binarySearch(char[] a, char key)",
            "comment": "Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
            "returnType": "int",
            "prompt": "Signature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:",
            "condition": "java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)",
            "signature": "binarySearch(float[] a, float key)",
            "comment": "Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.",
            "returnType": "int",
            "prompt": "Signature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:",
            "condition": "java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)",
            "signature": "binarySearch(long[] a, long key)",
            "comment": "Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
            "returnType": "int",
            "prompt": "Signature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the mappings from this map. The map will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.",
            "returnType": "void",
            "prompt": "Signature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:"
        },
        {
            "input": "Signature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:",
            "condition": "receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)",
            "signature": "org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)",
            "comment": "Constructs a new FilterListIterator that will not function until setPredicate is invoked.",
            "returnType": "",
            "prompt": "Signature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.",
            "returnType": "void",
            "prompt": "Signature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:",
            "condition": "java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)",
            "signature": "binarySearch(int[] a, int key)",
            "comment": "Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
            "returnType": "int",
            "prompt": "Signature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:"
        },
        {
            "input": "Signature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:",
            "condition": "org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)",
            "signature": "begin(java.net.URL url)",
            "comment": "Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.",
            "returnType": "void",
            "prompt": "Signature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:"
        },
        {
            "input": "Signature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:",
            "condition": "org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)",
            "signature": "begin(java.lang.String fileName)",
            "comment": "Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.",
            "returnType": "void",
            "prompt": "Signature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the elements from this list. The list will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Atomically removes all of the elements from this queue. The queue will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the elements from this list. The list will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:",
            "condition": "org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)",
            "signature": "org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)",
            "comment": "Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.",
            "returnType": "",
            "prompt": "Signature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:"
        },
        {
            "input": "Signature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:",
            "condition": "receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()",
            "signature": "defineDataFormat()",
            "comment": "Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.",
            "returnType": "weka.core.Instances",
            "prompt": "Signature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:"
        },
        {
            "input": "Signature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:",
            "condition": "org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()",
            "signature": "org.apache.commons.collections4.iterators.IteratorChain()",
            "comment": "Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.",
            "returnType": "",
            "prompt": "Signature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:"
        },
        {
            "input": "Signature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:",
            "condition": "receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()",
            "signature": "setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)",
            "comment": "Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.",
            "returnType": "void",
            "prompt": "Signature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:"
        },
        {
            "input": "Signature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:",
            "condition": "receiverObjectID.contains(e)<-receiverObjectID.add(e)",
            "signature": "add(E e)",
            "comment": "Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.",
            "returnType": "boolean",
            "prompt": "Signature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:"
        },
        {
            "input": "Signature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:",
            "condition": "receiverObjectID.isEmpty()<-receiverObjectID.clear()",
            "signature": "clear()",
            "comment": "Removes all of the elements from this list. The list will be empty after this call returns.",
            "returnType": "void",
            "prompt": "Signature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:",
            "condition": "receiverObjectID.sort()->receiverObjectID.binarySearch(key)",
            "signature": "binarySearch(float key)",
            "comment": "Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.",
            "returnType": "int",
            "prompt": "Signature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:"
        },
        {
            "input": "Signature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:",
            "condition": "if(){null}",
            "signature": "begin(long size)",
            "comment": "Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.",
            "returnType": "void",
            "prompt": "Signature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:"
        },
        {
            "input": "Signature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:",
            "condition": "java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)",
            "signature": "binarySearch(byte[] a, byte key)",
            "comment": "Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.",
            "returnType": "int",
            "prompt": "Signature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:"
        },
        {
            "input": "Signature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:",
            "condition": "ByteBlockPool->receiverObjectID.nextBuffer()",
            "signature": "nextBuffer()",
            "comment": "Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.",
            "returnType": "void",
            "prompt": "Signature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:"
        },
        {
            "input": "Signature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:",
            "condition": "org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)",
            "signature": "begin(java.net.URL url)",
            "comment": "Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.",
            "returnType": "void",
            "prompt": "Signature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:"
        },
        {
            "input": "Signature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:",
            "condition": "receiverObjectID.remove(o)->!receiverObjectID.contains(o)",
            "signature": "remove(java.lang.Object o)",
            "comment": "Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)",
            "returnType": "boolean",
            "prompt": "Signature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:"
        },
        {
            "input": "Signature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:",
            "condition": "receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()",
            "signature": "collect(org.apache.lucene.search.spans.SpanCollector collector)",
            "comment": "Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.",
            "returnType": "void",
            "prompt": "Signature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:"
        },
        {
            "input": "Signature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:",
            "condition": "receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)",
            "signature": "compareBottom(int doc)",
            "comment": "Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).",
            "returnType": "int",
            "prompt": "Signature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:"
        },
        {
            "input": "Signature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:",
            "condition": "receiverObjectID.end()->!receiverObjectID",
            "signature": "end()",
            "comment": "Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.",
            "returnType": "void",
            "prompt": "Signature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:"
        },
        {
            "input": "Signature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:",
            "condition": "receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()",
            "signature": "setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)",
            "comment": "Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.",
            "returnType": "void",
            "prompt": "Signature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.Reader reader)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(reader)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:"
        },
        {
            "input": "Signature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:",
            "condition": "receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()",
            "signature": "defineDataFormat()",
            "comment": "Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.",
            "returnType": "weka.core.Instances",
            "prompt": "Signature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void end()\nComment:Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void close()\nComment:Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions. @exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(\"control\").\nCondition:receiverObjectID.close()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:int binarySearch(long[] a, long key)\nComment:Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin fetching the URL stopping as soon as possible. Next graph events from the URL will be send by calling nextEvents(). Once begin() as been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.net.URLSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain(java.util.Iterator<? extends E> iterator)\nComment:Construct an IteratorChain with a single Iterator.  This method takes one iterator. The newly constructed iterator will iterate through that iterator. Thus calling this constructor on its own will have no effect other than decorating the input iterator.  You will normally use addIterator(Iterator) to add some more iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain(iterator)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.EnumerationIterator()\nComment:Constructs a new EnumerationIterator that will not function until setEnumeration(Enumeration) is called.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.EnumerationIterator()->org.apache.commons.collections4.iterators.EnumerationIterator.setEnumeration(java.util.Enumeration<? extends E>)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:"
        },
        {
            "input": "Signature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:",
            "condition": "receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()",
            "signature": "defineDataFormat()",
            "comment": "Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.",
            "returnType": "weka.core.Instances",
            "prompt": "Signature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(float key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(char[] text)\nComment:If ignoreCase is true for this Set, the text array will be directly modified. The user should never modify this text array after calling this method.\nCondition:!(receiverObjectID.add()->receiverObjectID)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:void begin(long size)\nComment:Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling #end(), you may call this method to reset the sink for another calculation.\nCondition:if(){null}\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.DefineFunction.getOutputDef()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:int binarySearch(java.util.List<? extends E> list, E key, java.util.Comparator<? super E> comparator, com.google.common.collect.SortedLists$KeyPresentBehavior presentBehavior, com.google.common.collect.SortedLists$KeyAbsentBehavior absentBehavior)\nComment:Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If there are elements in the list which compare as equal to the key, the choice of KeyPresentBehavior decides which index is returned. If no elements compare as equal to the key, the choice of KeyAbsentBehavior decides which index is returned. This method runs in log(n) time on random-access lists, which offer near-constant-time access to each list element.\nCondition:Collections.sort(list,comparator)->receiverObjectID.binarySearch(list,key,comparator,presentBehavior,absentBehavior)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());\nCondition:!(receiverObjectID.newSetFromMap(map)->map)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature:int binarySearch(long key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list (optional operation). The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(short[] a, short key)\nComment:Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort(short[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:"
        },
        {
            "input": "Signature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:",
            "condition": "receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()",
            "signature": "defineDataFormat()",
            "comment": "Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.",
            "returnType": "weka.core.Instances",
            "prompt": "Signature:int binarySearch(byte[] a, byte key)\nComment:Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort(byte[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:long prepareCommit()\nComment:first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either commit() to finish the commit, or rollback() to revert the commit and undo all changes done since the writer was opened.</p> <p>You can also just call commit() directly without prepareCommit first in which case that method will internally call prepareCommit.\nCondition:org.apache.lucene.index.IndexWriter.commit()<-receiverObjectID.prepareCommit()\n\n###\n\nSignature:int binarySearch(double key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:V remove(java.lang.Object key)\nComment:Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.\nCondition:receiverObjectID.remove(key)->!receiverObjectID.containsKey(key)\n\n###\n\nSignature:boolean remove(java.lang.Object o)\nComment:Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)\nCondition:receiverObjectID.remove(o)->!receiverObjectID.contains(o)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorEnumeration()\nComment:Constructs a new IteratorEnumeration that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.IteratorEnumeration()->org.apache.commons.collections4.iterators.IteratorEnumeration.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:void setQueryCachingPolicy(org.apache.lucene.search.QueryCachingPolicy queryCachingPolicy)\nComment:Set the QueryCachingPolicy to use for query caching. This method should be called before starting using this IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCachingPolicy)->receiverObjectID\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator()\nComment:Constructs a new FilterListIterator that will not function until setListIterator and setPredicate are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator()->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(java.util.ListIterator<? extends E>)\n\n###\n\nSignature:void setDaemon(boolean on)\nComment:Marks this thread as either a #isDaemon daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.  This method must be invoked before the thread is started.\nCondition:receiverObjectID.setDaemon(on)->receiverObjectID.start()\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all elements from the receiver. The receiver will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(byte key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void collect(org.apache.lucene.search.spans.SpanCollector collector)\nComment:Collect postings data from the leaves of the current Spans. This method should only be called after nextStartPosition(), and before NO_MORE_POSITIONS has been reached.\nCondition:receiverObjectID.collect(collector)<-org.apache.lucene.search.spans.Spans.nextStartPosition()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(org.apache.commons.collections4.Predicate<? super E> predicate)\nComment:Constructs a new FilterListIterator that will not function until setListIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(predicate)->org.apache.commons.collections4.iterators.FilterListIterator.setListIterator(ListIterator)\n\n###\n\nSignature:int binarySearch(float[] a, float key)\nComment:Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort(float[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean> map)\nComment:Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.\nCondition:receiverObjectID.newSetFromMap(map)->!map\n\n###\n\nSignature:int binarySearch(double[] a, double key)\nComment:Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort(double[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this priority queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set (optional operation). The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this deque. The deque will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void incRef()\nComment:Expert: increments the refCount of this IndexReader instance. RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding #decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until #decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:boolean tryIncRef()\nComment:Expert: increments the refCount of this IndexReader instance only if the IndexReader has not been closed yet and returns true iff the refCount was successfully incremented, otherwise false. If this method returns false the reader is either already closed or is currently being closed. Either way this reader instance shouldn't be used by an application unless true is returned.  RefCounts are used to determine when a reader can be closed safely, i.e. as soon as there are no more references. Be sure to always call a corresponding decRef, in a finally clause; otherwise the reader may never be closed. Note that close simply calls decRef(), which means that the IndexReader will not really be closed until decRef has been called for all outstanding references.\nCondition:receiverObjectID.decRef()<-receiverObjectID.incRef()\n\n###\n\nSignature:void setBottom(int slot)\nComment:Set the bottom slot, ie the \"weakest\" (sorted last) entry in the queue. When compareBottom(int) is called, you should compare against this slot. This will always be called before compareBottom(int).\nCondition:receiverObjectID.setBottom(slot)->receiverObjectID.compareBottom(int)\n\n###\n\nSignature:void begin(java.io.InputStream stream)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(stream)\n\n###\n\nSignature:void remove()\nComment:Removes the previously retrieved item from the underlying collection. This feature is only supported if the underlying collection's iterator method returns an implementation that supports it. This method can only be called after at least one next() method call. After a removal, the remove method may not be called again until another next has been performed. If the reset() is called, then remove may not be called until next() is called again.\nCondition:receiverObjectID.remove()<-receiverObjectID.next()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator(java.util.Iterator<? extends E> iterator)\nComment:Constructs a new FilterIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator(iterator)->org.apache.commons.collections4.iterators.FilterIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void end()\nComment:Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.\nCondition:receiverObjectID.end()->!receiverObjectID\n\n###\n\nSignature:void clear()\nComment:Removes all of the mappings from this map. The map will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:boolean removeAll(java.util.Collection<?> c)\nComment:Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.\nCondition:Collections.disjoint(receiverObjectID, c)<-receiverObjectID.removeAll(c)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this list. The list will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(char[] a, char key)\nComment:Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort(char[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.IteratorChain()\nComment:Construct an IteratorChain with no Iterators.  You will normally use addIterator(Iterator) to add some iterators after using this constructor.\nCondition:org.apache.commons.collections4.iterators.IteratorChain.addIterator(java.util.Iterator<? extends E>)<-receiverObjectID.org.apache.commons.collections4.iterators.IteratorChain()\n\n###\n\nSignature:void begin(java.net.URL url)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(url)\n\n###\n\nSignature:int binarySearch(char key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:boolean add(E e)\nComment:Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.\nCondition:receiverObjectID.contains(e)<-receiverObjectID.add(e)\n\n###\n\nSignature:void clear()\nComment:Atomically removes all of the elements from this queue. The queue will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:void setParameterDefs(java.util.ArrayList<weka.core.Attribute> paramDefs)\nComment:Set the structure of the parameters that are expected as input by this function. This must be called before getOutputDef() is called.\nCondition:receiverObjectID.setParameterDefs(paramDefs)->weka.core.pmml.BuiltInMath.getOutputDef()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterIterator()\nComment:Constructs a new FilterIterator that will not function until setIterator is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterIterator()->org.apache.commons.collections4.iterators.FilterIterator.setIterator(java.util.Iterator<? extends E>)\n\n###\n\nSignature:int compareBottom(int doc)\nComment:Compare the bottom of the queue with this doc. This will only invoked after setBottom has been called. This should return the same result as FieldComparator.compare(int,int)} as if bottom were slot1 and the new document were slot 2. For a search that hits many results, this method will be the hotspot (invoked by far the most frequently).\nCondition:receiverObjectID.compareBottom(doc)<-receiverObjectID.setBottom(int)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(short key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setEncoding(java.lang.String encoding)\nComment:Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.\nCondition:receiverObjectID.setEncoding(encoding)->receiverObjectID.publish(LogRecord)\n\n###\n\nSignature:int binarySearch(int[] a, int key)\nComment:Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\nCondition:java.util.Arrays.sort(a)->java.util.Arrays.binarySearch(a,key)\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this set. The set will be empty after this call returns.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature:int binarySearch(boolean key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature:void setQueryCache(org.apache.lucene.search.QueryCache queryCache)\nComment:Set the QueryCache to use when scores are not needed. A value of null indicates that query matches should never be cached. This method should be called before starting using this IndexSearcher. NOTE: When using a query cache, queries should not be modified after they have been passed to IndexSearcher.\nCondition:receiverObjectID.setQueryCache(queryCache)->receiverObjectID\n\n###\n\nSignature:void begin(java.lang.String fileName)\nComment:Begin reading the file stopping as soon as possible. Next graph events stored in the file will be sent by calling nextEvents() or nextStep(). Once begin() has been called, you must finish the reading process using end(). You cannot call begin() twice without having called end() in between.\nCondition:org.graphstream.stream.file.FileSource.end()<-receiverObjectID.begin(fileName)\n\n###\n\nSignature:int binarySearch(int key)\nComment:Searches the receiver for the specified value using the binary search algorithm. The receiver must must be sorted (as by the sort method) prior to making this call. If it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. If the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found.\nCondition:receiverObjectID.sort()->receiverObjectID.binarySearch(key)\n\n###\n\nSignature: org.apache.commons.collections4.iterators.TransformIterator()\nComment:Constructs a new TransformIterator that will not function until the setIterator and setTransformer(Transformer) methods are invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.TransformIterator()->org.apache.commons.collections4.iterators.TransformIterator.setIterator(java.util.Iterator<? extends I>)\n\n###\n\nSignature:void nextBuffer()\nComment:Advances the pool to its next buffer. This method should be called once after the constructor to initialize the pool. In contrast to the constructor a reset() call will advance the pool to its first buffer immediately.\nCondition:ByteBlockPool->receiverObjectID.nextBuffer()\n\n###\n\nSignature:void deactivateEvents()\nComment:De-activate any events activated for an element. This method MUST be called if activateEventsFor(Element) has been called.\nCondition:receiverObjectID.activateEventsFor(Element)->receiverObjectID.deactivateEvents()\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:receiverObjectID.defineDataFormat()->receiverObjectID.generateExample()\n\n###\n\nSignature:void clear()\nComment:Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.\nCondition:receiverObjectID.isEmpty()<-receiverObjectID.clear()\n\n###\n\nSignature: org.apache.commons.collections4.iterators.FilterListIterator(java.util.ListIterator<? extends E> iterator)\nComment:Constructs a new FilterListIterator that will not function until setPredicate is invoked.\nCondition:receiverObjectID.org.apache.commons.collections4.iterators.FilterListIterator(iterator)->org.apache.commons.collections4.iterators.FilterListIterator.setPredicate(org.apache.commons.collections4.Predicate<? super E>)\n\n###\n\nSignature:weka.core.Instances defineDataFormat()\nComment:Initializes the format for the dataset produced. Must be called before the generateExample or generateExamples methods are used. Re-initializes the random number generator with the given seed.\nCondition:"
        }
    ]
}